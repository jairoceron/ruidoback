"use strict";var Se=Object.defineProperty,Re=Object.defineProperties,De=Object.getOwnPropertyDescriptors,ze=Object.getOwnPropertySymbols,xe=Object.prototype.hasOwnProperty,Te=Object.prototype.propertyIsEnumerable,pe=Math.pow,Fe=(D,O,m)=>O in D?Se(D,O,{enumerable:!0,configurable:!0,writable:!0,value:m}):D[O]=m,we=(D,O)=>{for(var m in O||(O={}))xe.call(O,m)&&Fe(D,m,O[m]);if(ze)for(var m of ze(O))Te.call(O,m)&&Fe(D,m,O[m]);return D},me=(D,O)=>Re(D,De(O));(self.webpackChunkdashboard=self.webpackChunkdashboard||[]).push([[8365],{25461:(D,O,m)=>{function B(){return[1,0,0,0,1,0,0,0,1]}function S(A,E){return new Float64Array(A,E,9)}m.d(O,{a:()=>S,c:()=>B}),Object.freeze({__proto__:null,create:B,clone:function(A){return[A[0],A[1],A[2],A[3],A[4],A[5],A[6],A[7],A[8]]},fromValues:function(A,E,k,N,T,ne,G,re,oe){return[A,E,k,N,T,ne,G,re,oe]},createView:S})},38203:(D,O,m)=>{m.d(O,{c:()=>ce,g:()=>N,j:()=>le,k:()=>_,m:()=>T,s:()=>k});var B=m(25461),j=m(9334),W=m(10127),S=m(65566),x=m(6618),A=m(75660);function k(r,s,y){y*=.5;const d=Math.sin(y);return r[0]=d*s[0],r[1]=d*s[1],r[2]=d*s[2],r[3]=Math.cos(y),r}function N(r,s){const y=2*Math.acos(s[3]),d=Math.sin(y/2);return d>S.E?(r[0]=s[0]/d,r[1]=s[1]/d,r[2]=s[2]/d):(r[0]=1,r[1]=0,r[2]=0),y}function T(r,s,y){const d=s[0],b=s[1],g=s[2],v=s[3],C=y[0],M=y[1],Z=y[2],z=y[3];return r[0]=d*z+v*C+b*Z-g*M,r[1]=b*z+v*M+g*C-d*Z,r[2]=g*z+v*Z+d*M-b*C,r[3]=v*z-d*C-b*M-g*Z,r}function q(r,s,y,d){const b=s[0],g=s[1],v=s[2],C=s[3];let M,Z,z,V,H,ee=y[0],$=y[1],te=y[2],t=y[3];return Z=b*ee+g*$+v*te+C*t,Z<0&&(Z=-Z,ee=-ee,$=-$,te=-te,t=-t),1-Z>S.E?(M=Math.acos(Z),z=Math.sin(M),V=Math.sin((1-d)*M)/z,H=Math.sin(d*M)/z):(V=1-d,H=d),r[0]=V*b+H*ee,r[1]=V*g+H*$,r[2]=V*v+H*te,r[3]=V*C+H*t,r}function ce(r,s){return r[0]=-s[0],r[1]=-s[1],r[2]=-s[2],r[3]=s[3],r}function P(r,s){const y=s[0]+s[4]+s[8];let d;if(y>0)d=Math.sqrt(y+1),r[3]=.5*d,d=.5/d,r[0]=(s[5]-s[7])*d,r[1]=(s[6]-s[2])*d,r[2]=(s[1]-s[3])*d;else{let b=0;s[4]>s[0]&&(b=1),s[8]>s[3*b+b]&&(b=2);const g=(b+1)%3,v=(b+2)%3;d=Math.sqrt(s[3*b+b]-s[3*g+g]-s[3*v+v]+1),r[b]=.5*d,d=.5/d,r[3]=(s[3*g+v]-s[3*v+g])*d,r[g]=(s[3*g+b]+s[3*b+g])*d,r[v]=(s[3*v+b]+s[3*b+v])*d}return r}function _(r,s,y,d){const b=.5*Math.PI/180;s*=b,y*=b,d*=b;const g=Math.sin(s),v=Math.cos(s),C=Math.sin(y),M=Math.cos(y),Z=Math.sin(d),z=Math.cos(d);return r[0]=g*M*z-v*C*Z,r[1]=v*C*z+g*M*Z,r[2]=v*M*Z-g*C*z,r[3]=v*M*z+g*C*Z,r}const L=A.c,Ce=A.s,Me=A.a,Q=T,ae=A.b,Y=A.d,Ue=A.l,ue=A.e,X=ue,se=A.f,Ie=se,K=A.n,le=A.g,fe=A.h,R=(0,W.c)(),Pe=(0,W.f)(1,0,0),Oe=(0,W.f)(0,1,0),he=(0,j.a)(),be=(0,j.a)(),Ze=(0,B.c)();Object.freeze({__proto__:null,identity:function(r){return r[0]=0,r[1]=0,r[2]=0,r[3]=1,r},setAxisAngle:k,getAxisAngle:N,multiply:T,rotateX:function(r,s,y){y*=.5;const d=s[0],b=s[1],g=s[2],v=s[3],C=Math.sin(y),M=Math.cos(y);return r[0]=d*M+v*C,r[1]=b*M+g*C,r[2]=g*M-b*C,r[3]=v*M-d*C,r},rotateY:function(r,s,y){y*=.5;const d=s[0],b=s[1],g=s[2],v=s[3],C=Math.sin(y),M=Math.cos(y);return r[0]=d*M-g*C,r[1]=b*M+v*C,r[2]=g*M+d*C,r[3]=v*M-b*C,r},rotateZ:function(r,s,y){y*=.5;const d=s[0],b=s[1],g=s[2],v=s[3],C=Math.sin(y),M=Math.cos(y);return r[0]=d*M+b*C,r[1]=b*M-d*C,r[2]=g*M+v*C,r[3]=v*M-g*C,r},calculateW:function(r,s){const y=s[0],d=s[1],b=s[2];return r[0]=y,r[1]=d,r[2]=b,r[3]=Math.sqrt(Math.abs(1-y*y-d*d-b*b)),r},slerp:q,random:function(r){const s=(0,S.R)(),y=(0,S.R)(),d=(0,S.R)(),b=Math.sqrt(1-s),g=Math.sqrt(s);return r[0]=b*Math.sin(2*Math.PI*y),r[1]=b*Math.cos(2*Math.PI*y),r[2]=g*Math.sin(2*Math.PI*d),r[3]=g*Math.cos(2*Math.PI*d),r},invert:function(r,s){const y=s[0],d=s[1],b=s[2],g=s[3],v=y*y+d*d+b*b+g*g,C=v?1/v:0;return r[0]=-y*C,r[1]=-d*C,r[2]=-b*C,r[3]=g*C,r},conjugate:ce,fromMat3:P,fromEuler:_,str:function(r){return"quat("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+")"},copy:L,set:Ce,add:Me,mul:Q,scale:ae,dot:Y,lerp:Ue,length:ue,len:X,squaredLength:se,sqrLen:Ie,normalize:K,exactEquals:le,equals:fe,rotationTo:function(r,s,y){const d=(0,x.d)(s,y);return d<-.999999?((0,x.c)(R,Pe,s),(0,x.u)(R)<1e-6&&(0,x.c)(R,Oe,s),(0,x.n)(R,R),k(r,R,Math.PI),r):d>.999999?(r[0]=0,r[1]=0,r[2]=0,r[3]=1,r):((0,x.c)(R,s,y),r[0]=R[0],r[1]=R[1],r[2]=R[2],r[3]=1+d,K(r,r))},sqlerp:function(r,s,y,d,b,g){return q(he,s,b,g),q(be,y,d,g),q(r,he,be,2*g*(1-g)),r},setAxes:function(r,s,y,d){const b=Ze;return b[0]=y[0],b[3]=y[1],b[6]=y[2],b[1]=d[0],b[4]=d[1],b[7]=d[2],b[2]=-s[0],b[5]=-s[1],b[8]=-s[2],K(r,P(r,b))}})},9334:(D,O,m)=>{function B(){return[0,0,0,1]}function j(E){return[E[0],E[1],E[2],E[3]]}function S(E,k){return new Float64Array(E,k,4)}m.d(O,{I:()=>x,a:()=>B,b:()=>j,c:()=>S});const x=[0,0,0,1];Object.freeze({__proto__:null,create:B,clone:j,fromValues:function(E,k,N,T){return[E,k,N,T]},createView:S,IDENTITY:x})},98365:(D,O,m)=>{m.r(O),m.d(O,{default:()=>te});var B=m(60305),j=m(89868),W=m(38203);function S(){const t=new Float32Array(4);return t[3]=1,t}Object.freeze({__proto__:null,create:S,clone:function(t){const e=new Float32Array(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},fromValues:function(t,e,i,a){const u=new Float32Array(4);return u[0]=t,u[1]=e,u[2]=i,u[3]=a,u},createView:function(t,e){return new Float32Array(t,e,4)}});var N=m(6618),T=m(78522),ne=m(62733),G=m(56703),re=m(80266),oe=m(54121),q=m(65474),I=m(22795),ve=m(85071),ce=m(33870);const P=!0;function ie(t,e,i){return{identifier:String.fromCharCode.apply(null,new Uint8Array(t,i+0,10)),version:e.getUint16(i+10,P),checksum:e.getUint32(i+12,P)}}function Q(t,e,i){const a=[];e=ae(t,e,a);const u=[];for(let n=0;n<a.length;n++){u.length=0,e=ae(t,e,u);for(let c=0;c<u.length;c++)i.push(u[c]+a[n])}return e}function ae(t,e,i){const a=new DataView(t,e),u=a.getUint8(0),n=31&u,c=!!(32&u),f=(192&u)>>6;let o=0;if(0===f)o=a.getUint32(1,P),e+=5;else if(1===f)o=a.getUint16(1,P),e+=3;else{if(2!==f)throw new I.Z("lepcc-decode-error","Bad count type");o=a.getUint8(1),e+=2}if(c)throw new I.Z("lepcc-decode-error","LUT not implemented");const h=Math.ceil(o*n/8),l=new Uint8Array(t,e,h);let p=0,w=0,U=0;const F=-1>>>32-n;for(let J=0;J<o;J++){for(;w<n;)p|=l[U]<<w,w+=8,U+=1;i[J]=p&F,p>>>=n,w-=n,w+n>32&&(p|=l[U-1]>>8-w)}return e+U}const K=ce.Z.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");function le(t,e,i){let a="",u=0;for(;u<i;){const n=t[e+u];if(n<128)a+=String.fromCharCode(n),u++;else if(n>=192&&n<224){if(u+1>=i)throw new I.Z("utf8-decode-error","UTF-8 Decode failed. Two byte character was truncated.");a+=String.fromCharCode((31&n)<<6|63&t[e+u+1]),u+=2}else if(n>=224&&n<240){if(u+2>=i)throw new I.Z("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");a+=String.fromCharCode((15&n)<<12|(63&t[e+u+1])<<6|63&t[e+u+2]),u+=3}else{if(!(n>=240&&n<248))throw new I.Z("utf8-decode-error","UTF-8 Decode failed. Invalid multi byte sequence.");{if(u+3>=i)throw new I.Z("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const c=(7&n)<<18|(63&t[e+u+1])<<12|(63&t[e+u+2])<<6|63&t[e+u+3];a+=c>=65536?String.fromCharCode(55296+(c-65536>>10),56320+(1023&c)):String.fromCharCode(c),u+=4}}}return a}function fe(t,e){const i={byteOffset:0,byteCount:0,fields:Object.create(null)};let a=0;for(let u=0;u<e.length;u++){const n=e[u],c=n.valueType||n.type;i.fields[n.property]=(0,d[c])(t,a),a+=y[c].BYTES_PER_ELEMENT}return i.byteCount=a,i}function R(t,e){return new y[e.valueType](t,e.byteOffset,e.count*e.valuesPerElement)}function de(t,e,i){if(e!==t&&K.error(`Invalid ${i} buffer size\n expected: ${t}, actual: ${e})`),e<t)throw new I.Z("buffer-too-small","Binary buffer is too small",{expectedSize:t,actualSize:e})}const r={position:"position",normal:"normal",color:"color",uv0:"uv0",region:"uvRegion"};function s(t,e,i){if("lepcc-rgb"===t.encoding)return function(t){const e=new DataView(t,0);let i=0;const{identifier:a,version:u}=ie(t,e,i);if(i+=16,"ClusterRGB"!==a)throw new I.Z("lepcc-decode-error","Bad identifier");if(u>1)throw new I.Z("lepcc-decode-error","Unknown version");const n=function(t,e){return{sizeLo:t.getUint32(e+0,P),sizeHi:t.getUint32(e+4,P),count:t.getUint32(e+8,P),colorMapCount:t.getUint16(e+12,P),lookupMethod:t.getUint8(e+14),compressionMethod:t.getUint8(e+15)}}(e,i);if(i+=16,n.sizeHi*pe(2,32)+n.sizeLo!==t.byteLength)throw new I.Z("lepcc-decode-error","Bad size");if((2===n.lookupMethod||1===n.lookupMethod)&&0===n.compressionMethod){if(3*n.colorMapCount+n.count+i!==t.byteLength||n.colorMapCount>256)throw new I.Z("lepcc-decode-error","Bad count");const c=new Uint8Array(t,i,3*n.colorMapCount),f=new Uint8Array(t,i+3*n.colorMapCount,n.count),o=new Uint8Array(3*n.count);for(let h=0;h<n.count;h++){const l=f[h];o[3*h]=c[3*l],o[3*h+1]=c[3*l+1],o[3*h+2]=c[3*l+2]}return o}if(0===n.lookupMethod&&0===n.compressionMethod){if(3*n.count+i!==t.byteLength||0!==n.colorMapCount)throw new I.Z("lepcc-decode-error","Bad count");return new Uint8Array(t,i).slice()}if(n.lookupMethod<=2&&1===n.compressionMethod){if(i+3!==t.byteLength||1!==n.colorMapCount)throw new I.Z("lepcc-decode-error","Bad count");const c=e.getUint8(i),f=e.getUint8(i+1),o=e.getUint8(i+2),h=new Uint8Array(3*n.count);for(let l=0;l<n.count;l++)h[3*l]=c,h[3*l+1]=f,h[3*l+2]=o;return h}throw new I.Z("lepcc-decode-error","Bad method "+n.lookupMethod+","+n.compressionMethod)}(e);if("lepcc-intensity"===t.encoding)return function(t){const e=new DataView(t,0);let i=0;const{identifier:a,version:u}=ie(t,e,i);if(i+=16,"Intensity "!==a)throw new I.Z("lepcc-decode-error","Bad identifier");if(u>1)throw new I.Z("lepcc-decode-error","Unknown version");const n=function(t,e){return{sizeLo:t.getUint32(e+0,P),sizeHi:t.getUint32(e+4,P),count:t.getUint32(e+8,P),scaleFactor:t.getUint16(e+12,P),bitsPerPoint:t.getUint8(e+14),reserved:t.getUint8(e+15)}}(e,i);if(i+=16,n.sizeHi*pe(2,32)+n.sizeLo!==t.byteLength)throw new I.Z("lepcc-decode-error","Bad size");const c=new Uint16Array(n.count);if(8===n.bitsPerPoint){if(n.count+i!==t.byteLength)throw new I.Z("lepcc-decode-error","Bad size");const f=new Uint8Array(t,i,n.count);for(let o=0;o<n.count;o++)c[o]=f[o]*n.scaleFactor}else if(16===n.bitsPerPoint){if(2*n.count+i!==t.byteLength)throw new I.Z("lepcc-decode-error","Bad size");const f=new Uint16Array(t,i,n.count);for(let o=0;o<n.count;o++)c[o]=f[o]*n.scaleFactor}else{const f=[];if(ae(t,i,f)!==t.byteLength)throw new I.Z("lepcc-decode-error","Bad size");for(let o=0;o<n.count;o++)c[o]=f[o]*n.scaleFactor}return c}(e);if(null!=t.encoding&&""!==t.encoding)throw new I.Z("unknown-attribute-storage-info-encoding","Unknown Attribute Storage Info Encoding");t["attributeByteCounts "]&&!t.attributeByteCounts&&(K.warn("Warning: Trailing space in 'attributeByteCounts '."),t.attributeByteCounts=t["attributeByteCounts "]),"ObjectIds"===t.ordering[0]&&t.hasOwnProperty("objectIds")&&(K.warn("Warning: Case error in objectIds"),t.ordering[0]="objectIds");const a=function(t,e,i){const a=null!=e.header?fe(t,e.header):{byteOffset:0,byteCount:0,fields:{count:i}},u={header:a,byteOffset:a.byteCount,byteCount:0,entries:Object.create(null)};let n=a.byteCount;for(let c=0;c<e.ordering.length;c++){const f=e.ordering[c],o=(0,ve.d9)(e[f]);if(o.count=a.fields.count,"String"===o.valueType){if(o.byteOffset=n,o.byteCount=a.fields[f+"ByteCount"],"UTF-8"!==o.encoding)throw new I.Z("unsupported-encoding","Unsupported String encoding.",{encoding:o.encoding})}else{if(!b(o.valueType))throw new I.Z("unsupported-value-type","Unsupported binary valueType",{valueType:o.valueType});{const h=g(o.valueType);n+=n%h!=0?h-n%h:0,o.byteOffset=n,o.byteCount=h*o.valuesPerElement*o.count}}n+=o.byteCount,u.entries[f]=o}return u.byteCount=n-u.byteOffset,u}(e,t,i);de(a.byteOffset+a.byteCount,e.byteLength,"attribute");const u=a.entries.attributeValues||a.entries.objectIds;if(u){if("String"===u.valueType){const n=a.entries.attributeByteCounts,c=R(e,n),f=function(t,e){return new Uint8Array(t,e.byteOffset,e.byteCount)}(e,u);return function(t,e,i){const a=[];let u,n,c=0;for(n=0;n<t;n+=1){if(u=e[n],u>0){if(a.push(le(i,c,u-1)),0!==i[c+u-1])throw new I.Z("string-array-error","Invalid string array: missing null termination.")}else a.push(null);c+=u}return a}(n.count,c,f)}return R(e,u)}throw new I.Z("bad-attribute-storage-info","Bad attributeStorageInfo specification.")}const y={Float32:Float32Array,Float64:Float64Array,UInt8:Uint8Array,Int8:Int8Array,UInt16:Uint16Array,Int16:Int16Array,UInt32:Uint32Array,Int32:Int32Array},d={Float32:(t,e)=>new DataView(t,0).getFloat32(e,!0),Float64:(t,e)=>new DataView(t,0).getFloat64(e,!0),UInt8:(t,e)=>new DataView(t,0).getUint8(e),Int8:(t,e)=>new DataView(t,0).getInt8(e),UInt16:(t,e)=>new DataView(t,0).getUint16(e,!0),Int16:(t,e)=>new DataView(t,0).getInt16(e,!0),UInt32:(t,e)=>new DataView(t,0).getUint32(e,!0),Int32:(t,e)=>new DataView(t,0).getInt32(e,!0)};function b(t){return y.hasOwnProperty(t)}function g(t){return b(t)?y[t].BYTES_PER_ELEMENT:0}function C(t,e){if(null==t.encoding||""===t.encoding){const i=function(t,e){const i=fe(t,e&&e.header);let a=i.byteCount;const u={isDraco:!1,header:i,byteOffset:i.byteCount,byteCount:0,vertexAttributes:{}},n=i.fields,c=null!=n.vertexCount?n.vertexCount:n.count;for(const h of e.ordering){if(!e.vertexAttributes[h])continue;const l=me(we({},e.vertexAttributes[h]),{byteOffset:a,count:c});u.vertexAttributes[r[h]?r[h]:"_"+h]=l,a+=g(l.valueType)*l.valuesPerElement*c}const f=n.faceCount;if(e.faces&&f){u.faces={};for(const h of e.ordering){if(!e.faces[h])continue;const l=me(we({},e.faces[h]),{byteOffset:a,count:f});u.faces[h]=l,a+=g(l.valueType)*l.valuesPerElement*f}}const o=n.featureCount;if(e.featureAttributes&&e.featureAttributeOrder&&o){u.featureAttributes={};for(const h of e.featureAttributeOrder){if(!e.featureAttributes[h])continue;const l=me(we({},e.featureAttributes[h]),{byteOffset:a,count:o});u.featureAttributes[h]=l,a+=("UInt64"===l.valueType?8:g(l.valueType))*l.valuesPerElement*o}}return de(a,t.byteLength,"geometry"),u.byteCount=a-u.byteOffset,u}(e,t);if((0,B.Wi)(i.vertexAttributes.position))return;const a=R(e,i.vertexAttributes.position),u=i.header.fields,n=[u.offsetX,u.offsetY,u.offsetZ],c=[u.scaleX,u.scaleY,u.scaleZ],f=a.length/3,o=new Float64Array(3*f);for(let h=0;h<f;h++)o[3*h]=a[3*h]*c[0]+n[0],o[3*h+1]=a[3*h+1]*c[1]+n[1],o[3*h+2]=a[3*h+2]*c[2]+n[2];return o}if("lepcc-xyz"===t.encoding)return function(t){const e=new DataView(t,0);let i=0;const{identifier:a,version:u}=ie(t,e,i);if(i+=16,"LEPCC     "!==a)throw new I.Z("lepcc-decode-error","Bad identifier");if(u>1)throw new I.Z("lepcc-decode-error","Unknown version");const n=function(t,e){return{sizeLo:t.getUint32(e+0,P),sizeHi:t.getUint32(e+4,P),minX:t.getFloat64(e+8,P),minY:t.getFloat64(e+16,P),minZ:t.getFloat64(e+24,P),maxX:t.getFloat64(e+32,P),maxY:t.getFloat64(e+40,P),maxZ:t.getFloat64(e+48,P),errorX:t.getFloat64(e+56,P),errorY:t.getFloat64(e+64,P),errorZ:t.getFloat64(e+72,P),count:t.getUint32(e+80,P),reserved:t.getUint32(e+84,P)}}(e,i);if(i+=88,n.sizeHi*pe(2,32)+n.sizeLo!==t.byteLength)throw new I.Z("lepcc-decode-error","Bad size");const c=new Float64Array(3*n.count),f=[],o=[],h=[],l=[];if(i=Q(t,i,f),i=Q(t,i,o),i=Q(t,i,h),i=Q(t,i,l),i!==t.byteLength)throw new I.Z("lepcc-decode-error","Bad length");let p=0,w=0;for(let U=0;U<f.length;U++){w+=f[U];let F=0;for(let J=0;J<o[U];J++){F+=h[p];const ye=l[p];c[3*p]=Math.min(n.maxX,n.minX+2*n.errorX*F),c[3*p+1]=Math.min(n.maxY,n.minY+2*n.errorY*w),c[3*p+2]=Math.min(n.maxZ,n.minZ+2*n.errorZ*ye),p++}}return{errorX:n.errorX,errorY:n.errorY,errorZ:n.errorZ,result:c}}(e).result}function M(t,e,i){return(0,B.pC)(t)&&t.attributeInfo.useElevation?function(t,e){const i=new Float64Array(e);for(let a=0;a<e;a++)i[a]=t[3*a+2];return i}(e,i):(0,B.pC)(t)?s(t.attributeInfo.storageInfo,t.buffer,i):null}function V(t){return null==t||"none"===t?null:"low-four-bit"===t?e=>15&e:"high-four-bit"===t?e=>(240&e)>>4:"absolute-value"===t?e=>Math.abs(e):"modulo-ten"===t?e=>e%10:null}function H(t){let e=0;for(const i of t||[])e|=1<<i;return e}class ee{transform(e){const i=this._transform(e),a=[i.points.buffer,i.rgb.buffer];(0,B.pC)(i.pointIdFilterMap)&&a.push(i.pointIdFilterMap.buffer);for(const u of i.attributes)"buffer"in u.values&&(0,j.eP)(u.values.buffer)&&u.values.buffer!==i.rgb.buffer&&a.push(u.values.buffer);return Promise.resolve({result:i,transferList:a})}_transform(e){const i=C(e.schema,e.geometryBuffer);let a=i.length/3,u=null;const n=[],c=M(e.primaryAttributeData,i,a);(0,B.pC)(e.primaryAttributeData)&&c&&n.push({attributeInfo:e.primaryAttributeData.attributeInfo,values:c});const f=M(e.modulationAttributeData,i,a);(0,B.pC)(e.modulationAttributeData)&&f&&n.push({attributeInfo:e.modulationAttributeData.attributeInfo,values:f});let o=function(t,e,i,a){const{rendererJSON:u,isRGBRenderer:n}=t;let c=null,f=null;if(e&&n)c=e;else if(e&&"pointCloudUniqueValueRenderer"===u.type){f=q.Z.fromJSON(u);const o=f.colorUniqueValueInfos;c=new Uint8Array(3*a);const h=V(f.fieldTransformType);for(let l=0;l<a;l++){const p=(h?h(e[l]):e[l])+"";for(let w=0;w<o.length;w++)if(o[w].values.indexOf(p)>=0){c[3*l]=o[w].color.r,c[3*l+1]=o[w].color.g,c[3*l+2]=o[w].color.b;break}}}else if(e&&"pointCloudStretchRenderer"===u.type){f=oe.Z.fromJSON(u);const o=f.stops;c=new Uint8Array(3*a);const h=V(f.fieldTransformType);for(let l=0;l<a;l++){const p=h?h(e[l]):e[l],w=o.length-1;if(p<o[0].value)c[3*l]=o[0].color.r,c[3*l+1]=o[0].color.g,c[3*l+2]=o[0].color.b;else if(p>=o[w].value)c[3*l]=o[w].color.r,c[3*l+1]=o[w].color.g,c[3*l+2]=o[w].color.b;else for(let U=1;U<o.length;U++)if(p<o[U].value){const F=(p-o[U-1].value)/(o[U].value-o[U-1].value);c[3*l]=o[U].color.r*F+o[U-1].color.r*(1-F),c[3*l+1]=o[U].color.g*F+o[U-1].color.g*(1-F),c[3*l+2]=o[U].color.b*F+o[U-1].color.b*(1-F);break}}}else if(e&&"pointCloudClassBreaksRenderer"===u.type){f=re.Z.fromJSON(u);const o=f.colorClassBreakInfos;c=new Uint8Array(3*a);const h=V(f.fieldTransformType);for(let l=0;l<a;l++){const p=h?h(e[l]):e[l];for(let w=0;w<o.length;w++)if(p>=o[w].minValue&&p<=o[w].maxValue){c[3*l]=o[w].color.r,c[3*l+1]=o[w].color.g,c[3*l+2]=o[w].color.b;break}}}else{c=new Uint8Array(3*a);for(let o=0;o<c.length;o++)c[o]=255}if(i&&f&&f.colorModulation){const o=f.colorModulation.minValue,h=f.colorModulation.maxValue,l=.3;for(let p=0;p<a;p++){const w=i[p],U=w>=h?1:w<=o?l:l+(1-l)*(w-o)/(h-o);c[3*p]=U*c[3*p],c[3*p+1]=U*c[3*p+1],c[3*p+2]=U*c[3*p+2]}}return c}(e.rendererInfo,c,f,a);if(e.filterInfo&&e.filterInfo.length>0&&(0,B.pC)(e.filterAttributesData)){const l=e.filterAttributesData.map(p=>{const w=M(p,i,a),U={attributeInfo:p.attributeInfo,values:w};return n.push(U),U});u=new Uint32Array(a),a=function(t,e,i,a,u){const n=t.length/3;let c=0;for(let f=0;f<n;f++){let o=!0;for(let h=0;h<a.length&&o;h++){const{filterJSON:l}=a[h],p=u[h].values[f];switch(l.type){case"pointCloudValueFilter":{const w="exclude"===l.mode;-1!==l.values.indexOf(p)===w&&(o=!1);break}case"pointCloudBitfieldFilter":{const w=H(l.requiredSetBits),U=H(l.requiredClearBits);(p&w)===w&&0==(p&U)||(o=!1);break}case"pointCloudReturnFilter":{const w=15&p,U=p>>>4&15,F=U>1,J=1===w,ye=w===U;let Le=!1;for(const ge of l.includedReturns)if("last"===ge&&ye||"firstOfMany"===ge&&J&&F||"lastOfMany"===ge&&ye&&F||"single"===ge&&!F){Le=!0;break}Le||(o=!1);break}}}o&&(i[c]=f,t[3*c]=t[3*f],t[3*c+1]=t[3*f+1],t[3*c+2]=t[3*f+2],e[3*c]=e[3*f],e[3*c+1]=e[3*f+1],e[3*c+2]=e[3*f+2],c++)}return c}(i,o,u,e.filterInfo,l)}for(const l of e.userAttributesData){const p=M(l,i,a);n.push({attributeInfo:l.attributeInfo,values:p})}3*a<o.length&&(o=new Uint8Array(o.buffer.slice(0,3*a))),this._applyElevationOffsetInPlace(i,a,e.elevationOffset);const h=this._transformCoordinates(i,a,e.obb,G.Z.fromJSON(e.inSR),G.Z.fromJSON(e.outSR));return{obb:e.obb,points:h,rgb:o,attributes:n,pointIdFilterMap:u}}_transformCoordinates(e,i,a,u,n){if(!(0,ne.CM)(e,u,0,e,n,0,i))throw Error("Can't reproject");const c=(0,T.f)(a.center[0],a.center[1],a.center[2]),f=(0,T.c)(),o=(0,T.c)();(0,W.c)($,a.quaternion);const h=new Float32Array(3*i);for(let l=0;l<i;l++)f[0]=e[3*l]-c[0],f[1]=e[3*l+1]-c[1],f[2]=e[3*l+2]-c[2],(0,N.q)(o,f,$),a.halfSize[0]=Math.max(a.halfSize[0],Math.abs(o[0])),a.halfSize[1]=Math.max(a.halfSize[1],Math.abs(o[1])),a.halfSize[2]=Math.max(a.halfSize[2],Math.abs(o[2])),h[3*l]=f[0],h[3*l+1]=f[1],h[3*l+2]=f[2];return h}_applyElevationOffsetInPlace(e,i,a){if(0!==a)for(let u=0;u<i;u++)e[3*u+2]+=a}}const $=S();function te(){return new ee}}}]);