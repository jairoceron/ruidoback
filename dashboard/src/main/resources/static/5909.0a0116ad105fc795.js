"use strict";(self.webpackChunkdashboard=self.webpackChunkdashboard||[]).push([[5909],{44295:(wt,et,R)=>{R.d(et,{j:()=>U,b:()=>x});var K=R(61921),C=R(53181),o=R(67474);let w=null,z=null;function U(){return H.apply(this,arguments)}function H(){return(H=(0,K.Z)(function*(){return w||(w=t()),w})).apply(this,arguments)}function t(){return s.apply(this,arguments)}function s(){return(s=(0,K.Z)(function*(){z=yield((0,o.Z)("csp-restrictions")?yield R.e(8505).then(R.bind(R,78505)).then(function(h){return h.l}):yield R.e(5571).then(R.bind(R,15571)).then(function(h){return h.l})).load({locateFile:()=>(0,C.V)("esri/core/libs/libtess/libtess.wasm")})})).apply(this,arguments)}function x(l,h){const i=Math.max(l.length,128e3);return z.triangulate(l,h,i)}},9949:(wt,et,R)=>{R.d(et,{E:()=>K});class K{constructor(o,c){this.x=o,this.y=c}clone(){return new K(this.x,this.y)}equals(o,c){return o===this.x&&c===this.y}isEqual(o){return o.x===this.x&&o.y===this.y}setCoords(o,c){this.x=o,this.y=c}normalize(){const o=this.x,c=this.y,w=Math.sqrt(o*o+c*c);this.x/=w,this.y/=w}rightPerpendicular(){const o=this.x;this.x=this.y,this.y=-o}move(o,c){this.x+=o,this.y+=c}assign(o){this.x=o.x,this.y=o.y}assignAdd(o,c){this.x=o.x+c.x,this.y=o.y+c.y}assignSub(o,c){this.x=o.x-c.x,this.y=o.y-c.y}rotate(o,c){const w=this.x,z=this.y;this.x=w*o-z*c,this.y=w*c+z*o}scale(o){this.x*=o,this.y*=o}length(){const o=this.x,c=this.y;return Math.sqrt(o*o+c*c)}static distance(o,c){const w=c.x-o.x,z=c.y-o.y;return Math.sqrt(w*w+z*z)}static add(o,c){return new K(o.x+c.x,o.y+c.y)}static sub(o,c){return new K(o.x-c.x,o.y-c.y)}}},32727:(wt,et,R)=>{R.d(et,{I:()=>z,b:()=>w});var K=R(99155),C=R(9949),o=R(42367);class c{constructor(t,s,x){this.ratio=t,this.x=s,this.y=x}}class w{constructor(t,s,x,l=8,h=8){this.lines=[],this.starts=[],this.validateTessellation=!0,this.pixelRatio=l,this.pixelMargin=h,this.tileSize=K.I_*l,this.dz=t,this.yPos=s,this.xPos=x}setPixelMargin(t){t!==this.pixelMargin&&(this.pixelMargin=t,this.setExtent(this._extent))}setExtent(t){this._extent=t,this.finalRatio=this.tileSize/t*(1<<this.dz);let s=this.pixelRatio*this.pixelMargin;s/=this.finalRatio;const x=t>>this.dz;s>x&&(s=x),this.margin=s,this.xmin=x*this.xPos-s,this.ymin=x*this.yPos-s,this.xmax=this.xmin+x+2*s,this.ymax=this.ymin+x+2*s}reset(t){this.type=t,this.lines=[],this.starts=[],this.line=null,this.start=0}moveTo(t,s){this._pushLine(),this._prevIsIn=this._isIn(t,s),this._moveTo(t,s,this._prevIsIn),this._prevPt=new C.E(t,s),this._firstPt=new C.E(t,s),this._dist=0}lineTo(t,s){const x=this._isIn(t,s),l=new C.E(t,s),h=C.E.distance(this._prevPt,l);let i,r,y,u,B,M,d,g;if(x)this._prevIsIn?this._lineTo(t,s,!0):(i=this._prevPt,r=l,y=this._intersect(r,i),this.start=this._dist+h*(1-this._r),this._lineTo(y.x,y.y,!0),this._lineTo(r.x,r.y,!0));else if(this._prevIsIn)r=this._prevPt,i=l,y=this._intersect(r,i),this._lineTo(y.x,y.y,!0),this._lineTo(i.x,i.y,!1);else{const a=this._prevPt,m=l;if(a.x<=this.xmin&&m.x<=this.xmin||a.x>=this.xmax&&m.x>=this.xmax||a.y<=this.ymin&&m.y<=this.ymin||a.y>=this.ymax&&m.y>=this.ymax)this._lineTo(m.x,m.y,!1);else{const f=[];if((a.x<this.xmin&&m.x>this.xmin||a.x>this.xmin&&m.x<this.xmin)&&(u=(this.xmin-a.x)/(m.x-a.x),g=a.y+u*(m.y-a.y),g<=this.ymin?M=!1:g>=this.ymax?M=!0:f.push(new c(u,this.xmin,g))),(a.x<this.xmax&&m.x>this.xmax||a.x>this.xmax&&m.x<this.xmax)&&(u=(this.xmax-a.x)/(m.x-a.x),g=a.y+u*(m.y-a.y),g<=this.ymin?M=!1:g>=this.ymax?M=!0:f.push(new c(u,this.xmax,g))),(a.y<this.ymin&&m.y>this.ymin||a.y>this.ymin&&m.y<this.ymin)&&(u=(this.ymin-a.y)/(m.y-a.y),d=a.x+u*(m.x-a.x),d<=this.xmin?B=!1:d>=this.xmax?B=!0:f.push(new c(u,d,this.ymin))),(a.y<this.ymax&&m.y>this.ymax||a.y>this.ymax&&m.y<this.ymax)&&(u=(this.ymax-a.y)/(m.y-a.y),d=a.x+u*(m.x-a.x),d<=this.xmin?B=!1:d>=this.xmax?B=!0:f.push(new c(u,d,this.ymax))),0===f.length)this._lineTo(B?this.xmax:this.xmin,M?this.ymax:this.ymin,!0);else if(f.length>1&&f[0].ratio>f[1].ratio)this.start=this._dist+h*f[1].ratio,this._lineTo(f[1].x,f[1].y,!0),this._lineTo(f[0].x,f[0].y,!0);else{this.start=this._dist+h*f[0].ratio;for(let _=0;_<f.length;_++)this._lineTo(f[_].x,f[_].y,!0)}this._lineTo(m.x,m.y,!1)}}this._dist+=h,this._prevIsIn=x,this._prevPt=l}close(){if(this.line.length>2){const t=this._firstPt,s=this._prevPt;t.x===s.x&&t.y===s.y||this.lineTo(t.x,t.y);const x=this.line;let l=x.length;for(;l>=4&&(x[0].x===x[1].x&&x[0].x===x[l-2].x||x[0].y===x[1].y&&x[0].y===x[l-2].y);)x.pop(),x[0].x=x[l-2].x,x[0].y=x[l-2].y,--l}}result(t=!0){return this._pushLine(),0===this.lines.length?null:(3===this.type&&t&&U.simplify(this.tileSize,this.margin*this.finalRatio,this.lines),this.lines)}resultWithStarts(){if(2!==this.type)throw new Error("Only valid for lines");this._pushLine();const t=this.lines,s=t.length;if(0===s)return null;const x=[];for(let l=0;l<s;l++)x.push({line:t[l],start:this.starts[l]||0});return x}_isIn(t,s){return t>=this.xmin&&t<=this.xmax&&s>=this.ymin&&s<=this.ymax}_intersect(t,s){let x,l,h;if(s.x>=this.xmin&&s.x<=this.xmax)l=s.y<=this.ymin?this.ymin:this.ymax,h=(l-t.y)/(s.y-t.y),x=t.x+h*(s.x-t.x);else if(s.y>=this.ymin&&s.y<=this.ymax)x=s.x<=this.xmin?this.xmin:this.xmax,h=(x-t.x)/(s.x-t.x),l=t.y+h*(s.y-t.y);else{l=s.y<=this.ymin?this.ymin:this.ymax,x=s.x<=this.xmin?this.xmin:this.xmax;const i=(x-t.x)/(s.x-t.x),r=(l-t.y)/(s.y-t.y);i<r?(h=i,l=t.y+i*(s.y-t.y)):(h=r,x=t.x+r*(s.x-t.x))}return this._r=h,new C.E(x,l)}_pushLine(){this.line&&(1===this.type?this.line.length>0&&(this.lines.push(this.line),this.starts.push(this.start)):2===this.type?this.line.length>1&&(this.lines.push(this.line),this.starts.push(this.start)):3===this.type&&this.line.length>3&&(this.lines.push(this.line),this.starts.push(this.start))),this.line=[],this.start=0}_moveTo(t,s,x){3!==this.type?x&&(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),s=Math.round((s-(this.ymin+this.margin))*this.finalRatio),this.line.push(new C.E(t,s))):(x||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),s<this.ymin&&(s=this.ymin),s>this.ymax&&(s=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),s=Math.round((s-(this.ymin+this.margin))*this.finalRatio),this.line.push(new C.E(t,s)),this._is_h=!1,this._is_v=!1)}_lineTo(t,s,x){let l,h;if(3!==this.type)if(x){if(t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),s=Math.round((s-(this.ymin+this.margin))*this.finalRatio),this.line.length>0&&(l=this.line[this.line.length-1],l.equals(t,s)))return;this.line.push(new C.E(t,s))}else this.line&&this.line.length>0&&this._pushLine();else if(x||(t<this.xmin&&(t=this.xmin),t>this.xmax&&(t=this.xmax),s<this.ymin&&(s=this.ymin),s>this.ymax&&(s=this.ymax)),t=Math.round((t-(this.xmin+this.margin))*this.finalRatio),s=Math.round((s-(this.ymin+this.margin))*this.finalRatio),this.line&&this.line.length>0){l=this.line[this.line.length-1];const i=l.x===t,r=l.y===s;if(i&&r)return;this._is_h&&i||this._is_v&&r?(l.x=t,l.y=s,h=this.line[this.line.length-2],h.x===t&&h.y===s?(this.line.pop(),this.line.length<=1?(this._is_h=!1,this._is_v=!1):(h=this.line[this.line.length-2],this._is_h=h.x===t,this._is_v=h.y===s)):(this._is_h=h.x===t,this._is_v=h.y===s)):(this.line.push(new C.E(t,s)),this._is_h=i,this._is_v=r)}else this.line.push(new C.E(t,s))}}class z{setExtent(t){this._ratio=4096===t?1:4096/t}get validateTessellation(){return this._ratio<1}reset(t){this.lines=[],this.line=null}moveTo(t,s){this.line&&this.lines.push(this.line),this.line=[];const x=this._ratio;this.line.push(new C.E(t*x,s*x))}lineTo(t,s){const x=this._ratio;this.line.push(new C.E(t*x,s*x))}close(){const t=this.line;t&&!t[0].isEqual(t[t.length-1])&&t.push(t[0])}result(){return this.line&&this.lines.push(this.line),0===this.lines.length?null:this.lines}}class U{static simplify(t,s,x){if(!x)return;const l=-s,h=t+s,i=-s,r=t+s,y=[],u=[],B=x.length;for(let d=0;d<B;++d){const g=x[d];if(!g||g.length<2)continue;let a,m=g[0];const f=g.length;for(let _=1;_<f;++_)a=g[_],m.x===a.x&&(m.x<=l&&(m.y>a.y?(y.push(d),y.push(_),y.push(0),y.push(-1)):(u.push(d),u.push(_),u.push(0),u.push(-1))),m.x>=h&&(m.y<a.y?(y.push(d),y.push(_),y.push(1),y.push(-1)):(u.push(d),u.push(_),u.push(1),u.push(-1)))),m.y===a.y&&(m.y<=i&&(m.x<a.x?(y.push(d),y.push(_),y.push(2),y.push(-1)):(u.push(d),u.push(_),u.push(2),u.push(-1))),m.y>=r&&(m.x>a.x?(y.push(d),y.push(_),y.push(3),y.push(-1)):(u.push(d),u.push(_),u.push(3),u.push(-1)))),m=a}if(0===y.length||0===u.length)return;U.fillParent(x,u,y),U.fillParent(x,y,u);const M=[];U.calcDeltas(M,u,y),U.calcDeltas(M,y,u),U.addDeltas(M,x)}static fillParent(t,s,x){const l=x.length,h=s.length;for(let i=0;i<h;i+=4){const r=s[i],y=s[i+1],u=s[i+2],B=t[r][y-1],M=t[r][y];let d=8092,g=-1;for(let a=0;a<l;a+=4){if(x[a+2]!==u)continue;const m=x[a],f=x[a+1],_=t[m][f-1],E=t[m][f];switch(u){case 0:case 1:if((0,o.vX)(B.y,_.y,E.y)&&(0,o.vX)(M.y,_.y,E.y)){const p=Math.abs(E.y-_.y);p<d&&(d=p,g=a)}break;case 2:case 3:if((0,o.vX)(B.x,_.x,E.x)&&(0,o.vX)(M.x,_.x,E.x)){const p=Math.abs(E.x-_.x);p<d&&(d=p,g=a)}}}s[i+3]=g}}static calcDeltas(t,s,x){const l=s.length;for(let h=0;h<l;h+=4){const r=U.calcDelta(h,s,x,[]);t.push(s[h]),t.push(s[h+1]),t.push(s[h+2]),t.push(r)}}static calcDelta(t,s,x,l){const h=s[t+3];if(-1===h)return 0;const i=l.length;return i>1&&l[i-2]===h?0:(l.push(h),U.calcDelta(h,x,s,l)+1)}static addDeltas(t,s){const x=t.length;let l=0;for(let h=0;h<x;h+=4){const i=t[h+3];i>l&&(l=i)}for(let h=0;h<x;h+=4){const i=s[t[h]],r=t[h+1],y=l-t[h+3];switch(t[h+2]){case 0:i[r-1].x-=y,i[r].x-=y,1===r&&(i[i.length-1].x-=y),r===i.length-1&&(i[0].x-=y);break;case 1:i[r-1].x+=y,i[r].x+=y,1===r&&(i[i.length-1].x+=y),r===i.length-1&&(i[0].x+=y);break;case 2:i[r-1].y-=y,i[r].y-=y,1===r&&(i[i.length-1].y-=y),r===i.length-1&&(i[0].y-=y);break;case 3:i[r-1].y+=y,i[r].y+=y,1===r&&(i[i.length-1].y+=y),r===i.length-1&&(i[0].y+=y)}}}}},30274:(wt,et,R)=>{R.d(et,{z:()=>l});var K=R(99155);function C(h,i){return h.x===i.x&&h.y===i.y}function c(h,i){return h.x=i.y,h.y=-i.x,h}function w(h,i){return h.x=-i.y,h.y=i.x,h}function z(h,i){return h.x=i.x,h.y=i.y,h}function U(h,i){return h.x=-i.x,h.y=-i.y,h}function H(h){return Math.sqrt(h.x*h.x+h.y*h.y)}function t(h,i){return h.x*i.y-h.y*i.x}function s(h,i){return h.x*i.x+h.y*i.y}function x(h,i,r,y){return h.x=i.x*r+i.y*y,h.y=i.x*y-i.y*r,h}class l{constructor(i,r,y){this.writeVertex=i,this.writeTriangle=r,this.canUseThinTessellation=y,this.prevNormal={x:void 0,y:void 0},this.nextNormal={x:void 0,y:void 0},this.textureNormalLeft={x:0,y:1},this.textureNormalRight={x:0,y:-1},this.textureNormal={x:void 0,y:void 0},this.joinNormal={x:void 0,y:void 0},this.inner={x:void 0,y:void 0},this.outer={x:void 0,y:void 0},this.roundStart={x:void 0,y:void 0},this.roundEnd={x:void 0,y:void 0},this.startBreak={x:void 0,y:void 0},this.endBreak={x:void 0,y:void 0},this.innerPrev={x:void 0,y:void 0},this.innerNext={x:void 0,y:void 0},this.bevelStart={x:void 0,y:void 0},this.bevelEnd={x:void 0,y:void 0},this.bevelMiddle={x:void 0,y:void 0}}tessellate(i,r){(function(h){if(!h)return;const i=h.length;if(i<=1)return;let r=0;for(let y=1;y<i;y++)C(h[y],h[r])||++r===y||(h[r]=h[y]);h.length=r+1})(i),this.canUseThinTessellation&&r.halfWidth<K.tQ&&!r.offset?this.tessellateThin_(i,r):this.tessellate_(i,r)}tessellateThin_(i,r){if(i.length<2)return;const y=r.wrapDistance||65535;let u=r.initialDistance||0,B=!1,M=i[0].x,d=i[0].y;const g=i.length;for(let a=1;a<g;++a){B&&(B=!1,u=0);let m=i[a].x,f=i[a].y,_=m-M,E=f-d,p=Math.sqrt(_*_+E*E);if(_/=p,E/=p,u+p>y){B=!0;const e=(y-u)/p;p=y-u,m=(1-e)*M+e*m,f=(1-e)*d+e*f,--a}const b=this.writeVertex(M,d,0,0,_,E,E,-_,0,-1,u),X=this.writeVertex(M,d,0,0,_,E,-E,_,0,1,u);u+=p;const ht=this.writeVertex(m,f,0,0,_,E,E,-_,0,-1,u),n=this.writeVertex(m,f,0,0,_,E,-E,_,0,1,u);this.writeTriangle(b,X,ht),this.writeTriangle(X,ht,n),M=m,d=f}}tessellate_(i,r){const u=i[i.length-1],B=C(i[0],u);if(i.length<(B?3:2))return;const d=r.pixelCoordRatio,g=null!=r.capType?r.capType:0,a=null!=r.joinType?r.joinType:2,m=null!=r.miterLimit?Math.min(r.miterLimit,4):2,f=null!=r.roundLimit?Math.min(r.roundLimit,1.05):1.05,_=null!=r.halfWidth?r.halfWidth:2,E=!!r.textured;let p,b,X=null,ht=null;const n=this.prevNormal,e=this.nextNormal;let rt=-1,tt=-1;const T=this.joinNormal;let I,L;const ct=this.textureNormalLeft,mt=this.textureNormalRight,O=this.textureNormal;let N=-1,P=-1;const Tt=r.wrapDistance||65535;let D=r.initialDistance||0;const bt=this.writeVertex,Pt=this.writeTriangle,k=function(G,_t,nt,W,Q,J){const Y=bt(p,b,I,L,nt,W,G,_t,Q,J,D);return N>=0&&P>=0&&Y>=0&&Pt(N,P,Y),N=P,P=Y,Y};B&&(X=i[i.length-2],e.x=u.x-X.x,e.y=u.y-X.y,tt=H(e),e.x/=tt,e.y/=tt);let yt=!1;for(let G=0;G<i.length;++G){if(yt&&(yt=!1,D=0),X&&(n.x=-e.x,n.y=-e.y,rt=tt,D+rt>Tt&&(yt=!0)),yt){const v=(Tt-D)/rt;rt=Tt-D,X={x:(1-v)*X.x+v*i[G].x,y:(1-v)*X.y+v*i[G].y},--G}else X=i[G];p=X.x,b=X.y;const _t=G<=0&&!yt,nt=G===i.length-1;if(_t||(D+=rt),ht=nt?B?i[1]:null:i[G+1],ht?(e.x=ht.x-p,e.y=ht.y-b,tt=H(e),e.x/=tt,e.y/=tt):(e.x=void 0,e.y=void 0),!B){if(_t){w(T,e),I=T.x,L=T.y,2===g&&(k(-e.y-e.x,e.x-e.y,e.x,e.y,0,-1),k(e.y-e.x,-e.x-e.y,e.x,e.y,0,1)),1===g&&(k(-e.y-e.x,e.x-e.y,e.x,e.y,-1,-1),k(e.y-e.x,-e.x-e.y,e.x,e.y,-1,1)),1!==g&&0!==g||(k(-e.y,e.x,e.x,e.y,0,-1),k(e.y,-e.x,e.x,e.y,0,1));continue}if(nt){c(T,n),I=T.x,L=T.y,1!==g&&0!==g||(k(n.y,-n.x,-n.x,-n.y,0,-1),k(-n.y,n.x,-n.x,-n.y,0,1)),2===g&&(k(n.y-n.x,-n.x-n.y,-n.x,-n.y,0,-1),k(-n.y-n.x,n.x-n.y,-n.x,-n.y,0,1)),1===g&&(k(n.y-n.x,-n.x-n.y,-n.x,-n.y,1,-1),k(-n.y-n.x,n.x-n.y,-n.x,-n.y,1,1));continue}}let W,Q,J=-t(n,e);if(Math.abs(J)<.01)s(n,e)>0?(T.x=n.x,T.y=n.y,J=1,W=Number.MAX_VALUE,Q=!0):(w(T,e),J=1,W=1,Q=!1);else{T.x=(n.x+e.x)/J,T.y=(n.y+e.y)/J,W=H(T);const v=(W-1)*_*d;Q=W>4||v>rt&&v>tt}I=T.x,L=T.y;let Y=a;switch(a){case 0:W<1.05&&(Y=2);break;case 1:W<f&&(Y=2);break;case 2:W>m&&(Y=0)}switch(Y){case 2:if(k(T.x,T.y,-n.x,-n.y,0,-1),k(-T.x,-T.y,-n.x,-n.y,0,1),nt)break;if(E){const v=yt?0:D;N=this.writeVertex(p,b,I,L,e.x,e.y,T.x,T.y,0,-1,v),P=this.writeVertex(p,b,I,L,e.x,e.y,-T.x,-T.y,0,1,v)}break;case 0:{const v=J<0;let A,j,it,F;if(v){const V=N;N=P,P=V,A=ct,j=mt}else A=mt,j=ct;if(Q)it=v?w(this.innerPrev,n):c(this.innerPrev,n),F=v?c(this.innerNext,e):w(this.innerNext,e);else{const V=v?U(this.inner,T):z(this.inner,T);it=V,F=V}const Z=v?c(this.bevelStart,n):w(this.bevelStart,n);k(it.x,it.y,-n.x,-n.y,A.x,A.y);const dt=k(Z.x,Z.y,-n.x,-n.y,j.x,j.y);if(nt)break;const $=v?w(this.bevelEnd,e):c(this.bevelEnd,e);if(Q){const V=this.writeVertex(p,b,I,L,-n.x,-n.y,0,0,0,0,D);N=this.writeVertex(p,b,I,L,e.x,e.y,F.x,F.y,A.x,A.y,D),P=this.writeVertex(p,b,I,L,e.x,e.y,$.x,$.y,j.x,j.y,D),this.writeTriangle(dt,V,P)}else{if(E){const V=this.bevelMiddle;V.x=(Z.x+$.x)/2,V.y=(Z.y+$.y)/2,x(O,V,-n.x,-n.y),k(V.x,V.y,-n.x,-n.y,O.x,O.y),x(O,V,e.x,e.y),N=this.writeVertex(p,b,I,L,e.x,e.y,V.x,V.y,O.x,O.y,D),P=this.writeVertex(p,b,I,L,e.x,e.y,F.x,F.y,A.x,A.y,D)}else{const V=N;N=P,P=V}k($.x,$.y,e.x,e.y,j.x,j.y)}if(v){const V=N;N=P,P=V}break}case 1:{const v=J<0;let A,j;if(v){const S=N;N=P,P=S,A=ct,j=mt}else A=mt,j=ct;const it=v?U(this.inner,T):z(this.inner,T);let F,Z;Q?(F=v?w(this.innerPrev,n):c(this.innerPrev,n),Z=v?c(this.innerNext,e):w(this.innerNext,e)):(F=it,Z=it);const dt=v?c(this.roundStart,n):w(this.roundStart,n),$=v?w(this.roundEnd,e):c(this.roundEnd,e),V=k(F.x,F.y,-n.x,-n.y,A.x,A.y),pt=k(dt.x,dt.y,-n.x,-n.y,j.x,j.y);if(nt)break;const st=this.writeVertex(p,b,I,L,-n.x,-n.y,0,0,0,0,D);Q||this.writeTriangle(N,P,st);const q=U(this.outer,it),xt=this.writeVertex(p,b,I,L,e.x,e.y,$.x,$.y,j.x,j.y,D);let lt,at;const ft=W>2;if(ft){let S;W!==Number.MAX_VALUE?(q.x/=W,q.y/=W,S=s(n,q),S=(W*(S*S-1)+1)/S):S=-1,lt=v?c(this.startBreak,n):w(this.startBreak,n),lt.x+=n.x*S,lt.y+=n.y*S,at=v?w(this.endBreak,e):c(this.endBreak,e),at.x+=e.x*S,at.y+=e.y*S}x(O,q,-n.x,-n.y);const gt=this.writeVertex(p,b,I,L,-n.x,-n.y,q.x,q.y,O.x,O.y,D);x(O,q,e.x,e.y);const Et=E?this.writeVertex(p,b,I,L,e.x,e.y,q.x,q.y,O.x,O.y,D):gt,Mt=st,vt=E?this.writeVertex(p,b,I,L,e.x,e.y,0,0,0,0,D):st;let ot=-1,ut=-1;if(ft&&(x(O,lt,-n.x,-n.y),ot=this.writeVertex(p,b,I,L,-n.x,-n.y,lt.x,lt.y,O.x,O.y,D),x(O,at,e.x,e.y),ut=this.writeVertex(p,b,I,L,e.x,e.y,at.x,at.y,O.x,O.y,D)),E?ft?(this.writeTriangle(Mt,pt,ot),this.writeTriangle(Mt,ot,gt),this.writeTriangle(vt,Et,ut),this.writeTriangle(vt,ut,xt)):(this.writeTriangle(Mt,pt,gt),this.writeTriangle(vt,Et,xt)):ft?(this.writeTriangle(st,pt,ot),this.writeTriangle(st,ot,ut),this.writeTriangle(st,ut,xt)):(this.writeTriangle(st,pt,gt),this.writeTriangle(st,Et,xt)),Q?(N=this.writeVertex(p,b,I,L,e.x,e.y,Z.x,Z.y,A.x,A.y,D),P=xt):(N=E?this.writeVertex(p,b,I,L,e.x,e.y,Z.x,Z.y,A.x,A.y,D):V,this.writeTriangle(N,vt,xt),P=xt),v){const S=N;N=P,P=S}break}}}}}}}]);