"use strict";var Vt=Object.defineProperty,It=Object.getOwnPropertySymbols,Rt=Object.prototype.hasOwnProperty,Ht=Object.prototype.propertyIsEnumerable,Lt=(et,V,w)=>V in et?Vt(et,V,{enumerable:!0,configurable:!0,writable:!0,value:w}):et[V]=w,Et=(et,V)=>{for(var w in V||(V={}))Rt.call(V,w)&&Lt(et,w,V[w]);if(It)for(var w of It(V))Ht.call(V,w)&&Lt(et,w,V[w]);return et};(self.webpackChunkdashboard=self.webpackChunkdashboard||[]).push([[9391],{24570:(et,V,w)=>{w.d(V,{zY:()=>pt,v1:()=>ct,GP:()=>z,wp:()=>nt,XV:()=>q,zv:()=>gt,QK:()=>_t,ov:()=>K,hh:()=>ot,qh:()=>dt});var R=w(85071),C=w(52917),I=w(68602);function z(P){const x=(0,R.d9)(P);return function(P){P&&((0,C.oU)(P)?O(P.rings):(0,C.l9)(P)?O(P.paths):(0,C.aW)(P)&&X(P.points))}(x),x}function N(P){if(P)for(let x=P.length-1;x>0;--x)P[x][0]-=P[x-1][0],P[x][1]-=P[x-1][1]}function J(P){if(P)for(const x of P)N(x)}function X(P){if(P){const x=P.length;for(let D=1;D<x;++D)P[D][0]+=P[D-1][0],P[D][1]+=P[D-1][1]}}function O(P){if(P)for(const x of P)X(x)}function nt(P){P&&((0,C.oU)(P)?J(P.rings):(0,C.l9)(P)?J(P.paths):(0,C.aW)(P)&&N(P.points))}function K(P){if(P)for(const x of P)ot(x)}function ot(P){P&&P.reverse()}function q(P,x,D){return[P[0]+(x[0]-P[0])*D,P[1]+(x[1]-P[1])*D]}function _t(P){return!(!P||0===P.length)&&P[0][0]===P[P.length-1][0]&&P[0][1]===P[P.length-1][1]}function gt(P){return P[4]}function dt(P,x){P[4]=x}class ct{constructor(x,D,lt,Z){this.acceptPolygon=D,this.acceptPolyline=lt,this.geomUnitsPerPoint=Z,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,x&&((0,C.oU)(x)?D&&(this.multiPath=x.rings,this.isClosed=!0):(0,C.l9)(x)?lt&&(this.multiPath=x.paths,this.isClosed=!1):(0,C.YX)(x)&&D&&(this.multiPath=ht(x).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new I.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const x=this.processPath(this.multiPath[this.pathIndex]);if(x)return x}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class pt{constructor(x,D,lt,Z){this.inputGeometries=x,this.acceptPolygon=D,this.acceptPolyline=lt,this.geomUnitsPerPoint=Z,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let x=this.inputGeometries.next();for(;x;){if((0,C.oU)(x)?this.acceptPolygon&&(this.multiPath=x.rings,this.isClosed=!0):(0,C.l9)(x)?this.acceptPolyline&&(this.multiPath=x.paths,this.isClosed=!1):(0,C.YX)(x)&&this.acceptPolygon&&(this.multiPath=ht(x).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}x=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const x=this.processPath(this.multiPath[this.pathIndex]);if(x)return x}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function ht(P){return{rings:[[[P.xmin,P.ymin],[P.xmin,P.ymax],[P.xmax,P.ymax],[P.xmax,P.ymin],[P.xmin,P.ymin]]]}}},14511:(et,V,w)=>{w.d(V,{M:()=>C}),w(85071);class C{constructor(N){this._geometry=N}next(){const N=this._geometry;return this._geometry=null,N}}},60196:(et,V,w)=>{w.d(V,{h:()=>Ot,W:()=>Yt});var R=w(85071),C=w(52917),I=w(24570);let z=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new N(s,n,r)}}return h.instance=null,h})();class N{constructor(e,s,n){this._inputGeometries=e,this._angleTolerance=void 0!==s.angleTolerance?s.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let e=this._inputGeometries.next();for(;e;){if((0,C.oU)(e)){this._isClosed=!0;const s=(0,R.d9)(e);return this._processMultipath(s.rings),s}if((0,C.l9)(e)){this._isClosed=!1;const s=(0,R.d9)(e);return this._processMultipath(s.paths),s}if((0,C.YX)(e)){if(this._maxCosAngle)return e;this._isClosed=!0;const s=[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]];return this._processPath(s),{rings:[s]}}e=this._inputGeometries.next()}return null}_processMultipath(e){if(e)for(const s of e)this._processPath(s)}_processPath(e){if(e){let s,n,r,l,_,p,m=e.length,M=e[0];this._isClosed&&++m;for(let d=1;d<m;++d){let A;A=this._isClosed&&d===m-1?e[0]:e[d];const S=A[0]-M[0],v=A[1]-M[1],E=Math.sqrt(S*S+v*v);d>1&&E>0&&r>0&&(s*S+n*v)/E/r<=this._maxCosAngle&&(0,I.qh)(M,1),1===d&&(l=S,_=v,p=E),E>0&&(M=A,s=S,n=v,r=E)}this._isClosed&&r>0&&p>0&&(s*l+n*_)/p/r<=this._maxCosAngle&&(0,I.qh)(e[0],1)}}}const J=.03;class X{constructor(){this._path=[]}path(){return this._path}addPath(e,s){s||e.reverse(),Array.prototype.push.apply(this._path,e),s||e.reverse()}static mergePath(e,s){s&&Array.prototype.push.apply(e,s)}startPath(e){this._path.push(e)}lineTo(e){this._path.push(e)}close(){const e=this._path;e.length>1&&(e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]||e.push([e[0][0],e[0][1]]))}}class O{constructor(e=0,s=!1){}normalize(e){const s=Math.sqrt(e[0]*e[0]+e[1]*e[1]);e[0]/=s,e[1]/=s}calculateLength(e,s){const n=s[0]-e[0],r=s[1]-e[1];return Math.sqrt(n*n+r*r)}calculateSegLength(e,s){return this.calculateLength(e[s],e[s+1])}calculatePathLength(e){let s=0;const n=e?e.length:0;for(let r=0;r<n-1;++r)s+=this.calculateSegLength(e,r);return s}calculatePathArea(e){let s=0;const n=e?e.length:0;for(let r=0;r<n-1;++r)s+=(e[r+1][0]-e[r][0])*(e[r+1][1]+e[r][1]);return s/2}getCoord2D(e,s,n){return[e[0]+(s[0]-e[0])*n,e[1]+(s[1]-e[1])*n]}getSegCoord2D(e,s,n){return this.getCoord2D(e[s],e[s+1],n)}getAngle(e,s,n){return Math.atan2(s[1]-e[1],s[0]-e[0])}getSegAngle(e,s,n){return this.getAngle(e[s],e[s+1],n)}getAngleCS(e,s,n){const r=s[0]-e[0],l=s[1]-e[1],_=Math.sqrt(r*r+l*l);return _>0?[r/_,l/_]:[1,0]}getSegAngleCS(e,s,n){return this.getAngleCS(e[s],e[s+1],n)}cut(e,s,n,r){return[n<=0?e[s]:this.getSegCoord2D(e,s,n),r>=1?e[s+1]:this.getSegCoord2D(e,s,r)]}addSegment(e,s,n){n&&e.push(s[0]),e.push(s[1])}getSubCurve(e,s,n){const r=[];return this.appendSubCurve(r,e,s,n)?r:null}appendSubCurve(e,s,n,r){const l=s?s.length-1:0;let _=0,p=!0,m=0;for(;m<l;){const M=this.calculateSegLength(s,m);if(0!==M){if(p){if(_+M>n){let A=1,S=!1;_+M>=r&&(A=(r-_)/M,S=!0);const v=this.cut(s,m,(n-_)/M,A);if(v&&this.addSegment(e,v,p),S)break;p=!1}}else{if(_+M>r){const d=this.cut(s,m,0,(r-_)/M);d&&this.addSegment(e,d,p);break}this.addSegment(e,[s[m],s[m+1]],p)}_+=M,++m}else++m}return!0}getCIMPointAlong(e,s){const n=e?e.length-1:0;let r=0,l=-1;for(;l<n;){++l;const _=this.calculateSegLength(e,l);if(0!==_){if(r+_>s)return this.getCoord2D(e[l],e[l+1],(s-r)/_);r+=_}}return null}isEmpty(e,s){if(!e||e.length<=1)return!0;const n=e?e.length-1:0;let r=-1;for(;r<n;)if(++r,e[r+1][0]!==e[r][0]||e[r+1][1]!==e[r][1]||s&&e[r+1][2]!==e[r][2])return!1;return!0}offset(e,s,n,r,l){if(!e||e.length<2)return null;let _=e.length;const p=e[0][0]===e[_-1][0]&&e[0][1]===e[_-1][1];if(p){if(e.length<3)return null;--_}const m=[];let M=p?e[_-1]:null,d=e[0];for(let A=0;A<_;A++){const S=A===_-1?p?e[0]:null:e[A+1];if(M)if(S){const v=[S[0]-d[0],S[1]-d[1]];this.normalize(v);const E=[d[0]-M[0],d[1]-M[1]];this.normalize(E);const at=E[0]*v[1]-E[1]*v[0],F=E[0]*v[0]+E[1]*v[1];if(at>=0==s<=0){const tt=[v[0]-E[0],v[1]-E[1]];this.normalize(tt);const j=Math.sqrt((1+F)/2);if(j>1/r){const U=-Math.abs(s)/j;m.push([d[0]-tt[0]*U,d[1]-tt[1]*U])}}else switch(n){case"Mitered":{const tt=Math.sqrt((1+F)/2);if(tt>0&&1/tt<r){const j=[v[0]-E[0],v[1]-E[1]];this.normalize(j);const U=Math.abs(s)/tt;m.push([d[0]-j[0]*U,d[1]-j[1]*U]);break}}case"Bevelled":m.push([d[0]+E[1]*s,d[1]-E[0]*s]),m.push([d[0]+v[1]*s,d[1]-v[0]*s]);break;case"Rounded":{m.push([d[0]+E[1]*s,d[1]-E[0]*s]);const tt=5,j=1/tt;let U=j;for(let Pt=1;Pt<tt;Pt++,U+=j){const kt=[E[1]*(1-U)+v[1]*U,-E[0]*(1-U)-v[0]*U];this.normalize(kt),m.push([d[0]+kt[0]*s,d[1]+kt[1]*s])}m.push([d[0]+v[1]*s,d[1]-v[0]*s]);break}default:if(at<0)m.push([d[0]+(E[1]+E[0])*s,d[1]+(E[1]-E[0])*s]),m.push([d[0]+(v[1]-v[0])*s,d[1]-(v[0]+v[1])*s]);else{const tt=Math.sqrt((1+Math.abs(F))/2),j=[v[0]-E[0],v[1]-E[1]];this.normalize(j);const U=s/tt;m.push([d[0]-j[0]*U,d[1]-j[1]*U])}}}else{const v=[d[0]-M[0],d[1]-M[1]];this.normalize(v),m.push([d[0]+v[1]*s,d[1]-v[0]*s])}else{const v=[S[0]-d[0],S[1]-d[1]];this.normalize(v),m.push([d[0]+v[1]*s,d[1]-v[0]*s])}M=d,d=S}return p&&m.push([m[0][0],m[0][1]]),m}}const $=1.7320508075688772;let ot=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new q(s,n,r)}}return h.instance=null,h})();class q extends I.zY{constructor(e,s,n){super(e,!1,!0),this._curveHelper=new O,this._width=(void 0!==s.width?s.width:5)*n,this._arrowType=void 0!==s.geometricEffectArrowType?s.geometricEffectArrowType:"OpenEnded",this._offsetFlattenError=J*n}processPath(e){switch(this._arrowType){default:return this._constructSimpleArrow(e,!0);case"Block":return this._constructSimpleArrow(e,!1);case"Crossed":return this._constructCrossedArrow(e)}}_constructSimpleArrow(e,s){const n=this._curveHelper.calculatePathLength(e);let r=this._width;n<2*r&&(r=n/2);const l=this._curveHelper.getSubCurve(e,0,n-r);if(!l)return null;const _=r/2;if(this._curveHelper.isEmpty(l,!1))return null;const p=this._constructOffset(l,-_);if(!p)return null;const m=this._constructOffset(l,_);if(!m)return null;const M=this._constructArrowBasePoint(p,-_/2);if(!M)return null;const d=this._constructArrowBasePoint(m,_/2);if(!d)return null;const A=e[e.length-1];s||(this._makeControlPoint(m,!0),this._makeControlPoint(p,!0));const S=new X;return S.addPath(m,!0),S.lineTo(d),this._makeControlPoint(S.path()),S.lineTo(A),this._makeControlPoint(S.path()),S.lineTo(M),this._makeControlPoint(S.path()),S.addPath(p,!1),s?{paths:[S.path()]}:(S.close(),{rings:[S.path()]})}_constructCrossedArrow(e){const s=this._curveHelper.calculatePathLength(e);let n=this._width;s<n*(1+$+1)&&(n=s/(1+$+1));const r=this._curveHelper.getSubCurve(e,0,s-n*(1+$));if(!r)return null;const l=n/2;if(this._curveHelper.isEmpty(r,!1))return null;const _=this._constructOffset(r,l);if(!_)return null;const p=this._constructOffset(r,-l);if(!p)return null;const m=this._curveHelper.getSubCurve(e,0,s-n);if(!m||this._curveHelper.isEmpty(m,!1))return null;const M=this._constructOffset(m,l);if(!M)return null;const d=this._constructOffset(m,-l);if(!d)return null;const A=M[M.length-1],S=this._constructArrowBasePoint(M,l/2);if(!S)return null;const v=d[d.length-1],E=this._constructArrowBasePoint(d,-l/2);if(!E)return null;const at=e[e.length-1];this._makeControlPoint(_,!1),this._makeControlPoint(p,!1);const F=new X;return F.addPath(_,!0),this._makeControlPoint(F.path()),F.lineTo(v),F.lineTo(E),this._makeControlPoint(F.path()),F.lineTo(at),this._makeControlPoint(F.path()),F.lineTo(S),this._makeControlPoint(F.path()),F.lineTo(A),this._makeControlPoint(F.path()),F.addPath(p,!1),{paths:[F.path()]}}_constructOffset(e,s){return this._curveHelper.offset(e,s,"Rounded",4,this._offsetFlattenError)}_constructArrowBasePoint(e,s){if(!e||e.length<2)return null;const n=e[e.length-2],r=e[e.length-1],l=[r[0]-n[0],r[1]-n[1]];return this._curveHelper.normalize(l),[r[0]+l[1]*s,r[1]-l[0]*s]}_makeControlPoint(e,s=!1){(0,I.qh)(s?e[0]:e[e.length-1],1)}}let _t=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new gt(s,n,r)}}return h.instance=null,h})();class gt{constructor(e,s,n){this._inputGeometries=e,this._curveHelper=new O,this._size=(void 0!==s.size?s.size:1)*n,this._offsetFlattenError=J*n}next(){let e=this._inputGeometries.next();for(;e;){if((0,C.YX)(e))if(this._size>0){const n=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],this._size,"Rounded",4,this._offsetFlattenError);if(n)return{rings:[n]}}else{if(!(this._size<0))return e;if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._size>0)return{xmin:e.xmin-this._size,xmax:e.xmax+this._size,ymin:e.ymin-this._size,ymax:e.ymax+this._size}}if((0,C.oU)(e)){if(0===this._size)return e;const s=[];for(const n of e.rings){const r=this._curveHelper.offset(n,this._size,"Rounded",4,this._offsetFlattenError);r&&s.push(r)}if(s.length)return{rings:s}}if((0,C.l9)(e)&&this._size>0){const s=[];for(const n of e.paths)if(n&&n.length>1){const r=this._curveHelper.offset(n,this._size,"Rounded",4,this._offsetFlattenError),l=this._curveHelper.offset(n,-this._size,"Rounded",4,this._offsetFlattenError);if(r&&l){for(let _=l.length-1;_>=0;_--)r.push(l[_]);r.push([r[0][0],r[0][1]]),s.push(r)}}if(s.length)return{rings:s}}(0,C.wp)(e),e=this._inputGeometries.next()}return null}}let dt=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new ct(s,n,r)}}return h.instance=null,h})();class ct extends I.zY{constructor(e,s,n){super(e,!0,!0),this._curveHelper=new O,this._beginCut=(void 0!==s.beginCut?s.beginCut:1)*n,this._endCut=(void 0!==s.endCut?s.endCut:1)*n,this._middleCut=(void 0!==s.middleCut?s.middleCut:0)*n,this._invert=void 0!==s.invert&&s.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(e){const s=this._beginCut,n=this._endCut,r=this._middleCut,l=this._curveHelper.calculatePathLength(e),_=[];if(this._invert){if(0!==s||0!==n||0!==r)if(s+n+r>=l)_.push(e);else{let p=this._curveHelper.getSubCurve(e,0,s);p&&_.push(p),p=this._curveHelper.getSubCurve(e,.5*(l-r),.5*(l+r)),p&&_.push(p),p=this._curveHelper.getSubCurve(e,l-n,n),p&&_.push(p)}}else if(0===s&&0===n&&0===r)_.push(e);else if(!(s+n+r>=l))if(0===r){const p=this._curveHelper.getSubCurve(e,s,l-n);p&&_.push(p)}else{let p=this._curveHelper.getSubCurve(e,s,.5*(l-r));p&&_.push(p),p=this._curveHelper.getSubCurve(e,.5*(l+r),l-n),p&&_.push(p)}return 0===_.length?null:{paths:_}}}class ht{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(e,s,n=!0){if(this._setEmpty(),!e||0===e.length)return!1;for(let r=0;r<e.length;r++){let l=Math.abs(e[r]);n&&l<1e-7&&(l=1e-7),this._values.push(l),this._length+=l}return s&&1&e.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(e){const s=this._values?this._values.length:0;for(let n=0;n<s;++n)this._values[n]*=e;this._length*=e,this.extPtGap*=e,this.ctrlPtGap*=e}addValue(e){this._length+=e,this._values.push(e)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}class P{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(e){e.segment=this.segment,e.segmentLength=this.segmentLength,e.abscissa=this.abscissa,e.isPathEnd=this.isPathEnd,e.isPartEnd=this.isPartEnd}}class x extends O{constructor(e=0,s=!1){super(e,s),this._tolerance=J,this._currentPosition=new P}updateTolerance(e){this._tolerance=J*e}init(e,s,n=!0){return n?(this._patternLength=s.length(),this._partExtPtGap=s.extPtGap,this._partCtrlPtGap=s.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=e,this._seg=-1,this.setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(e,s=0){const n=new P;return!!this._nextPosition(e,n,null,s)&&(n.copyTo(this._currentPosition),!0)}curPointAndAngle(e){e.pt=this._getPoint(this._currentPosition);const[s,n]=this._getAngle(this._currentPosition);e.ca=s,e.sa=n}nextPointAndAngle(e,s,n=0){const r=new P;if(!this._nextPosition(e,r,null,n))return!1;r.copyTo(this._currentPosition),s.pt=this._getPoint(r);const[l,_]=this._getAngle(r);return s.ca=l,s.sa=_,!0}nextCurve(e){if(0===e)return null;const s=[],n=new P;return this._nextPosition(e,n,s,1)?(n.copyTo(this._currentPosition),s):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(e,s,n,r){if(this._currentPosition.isPathEnd)return!1;let l=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(l/=this._currentPosition.segmentLength),this._currentPosition.copyTo(s);s.abscissa+e*this._partLengthRatio>s.segmentLength+this._tolerance;){if(n){if(0===n.length)if(0===l){const p=this._path[s.segment];n.push([p[0],p[1]])}else n.push(this.getSegCoord2D(this._path,s.segment,l));const _=this._path[s.segment+1];n.push([_[0],_[1]])}if(l=0,e-=(s.segmentLength-s.abscissa)/this._partLengthRatio,this._partSegCount)s.segment=this.nextSegment(),s.segmentLength=this.calculateSegLength(this._path,s.segment),s.abscissa=0,this._partSegCount--;else{if(!this.setPosAtNextPart())return 0!==r&&(s.segmentLength=this.calculateSegLength(this._path,s.segment),s.isPartEnd=!0,1===r?(s.abscissa=s.segmentLength,s.isPathEnd=!0):s.abscissa=s.segmentLength+e,!0);this._currentPosition.copyTo(s)}}if(s.abscissa+=e*this._partLengthRatio,n){if(0===n.length)if(0===l){const p=this._path[s.segment];n.push([p[0],p[1]])}else n.push(this.getSegCoord2D(this._path,s.segment,l));const _=s.abscissa/s.segmentLength;if(1===_){const p=this._path[s.segment+1];n.push([p[0],p[1]])}else n.push(this.getSegCoord2D(this._path,s.segment,_))}return this._partSegCount||Math.abs(s.abscissa-s.segmentLength)<this._tolerance&&(s.isPathEnd=this._partIsLast,s.isPartEnd=!0),!0}_getPoint(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_getAngle(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}setPosAtNextPart(){for(;this._partSegCount;)this.hasNextSegment()&&this.nextSegment(),this._partSegCount--;if(!this.hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this.hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this.nextSegment()),this._partSegCount++,1===(0,I.zv)(this._path[this.getEndPointIndex()])){this._partIsLast=!this.hasNextSegment();break}let e=this._partSegCount;for(;e;)this.previousSegment(),--e;this._currentPosition.segment=this.nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const s=this.getStartPointIndex();this._ctrlPtBegin=1===(0,I.zv)(this._path[s]);let n=s+this._partSegCount+1;if(n>=this._path.length&&(n=0),this._ctrlPtEnd=1===(0,I.zv)(this._path[n]),this._patternLength>0){const r=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,l=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let _=Math.round((this._partLength-(r+l))/this._patternLength);_<=0&&(_=r+l>0?0:1),this._partLengthRatio=this._partLength/(r+l+_*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}hasNextSegment(){return this._seg<this._path.length-2}previousSegment(){return--this._seg}nextSegment(){return++this._seg}getStartPointIndex(){return this._seg}getEndPointIndex(){return this._seg+1}}let D=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new lt(s,n,r)}}return h.instance=null,h})();class lt extends I.zY{constructor(e,s,n){super(e,!0,!0),this._walker=new x,this._walker.updateTolerance(n),this._endings=s.lineDashEnding,this._customDashPos=void 0!==s.offsetAlongLine?s.offsetAlongLine*n:0,this._offsetAtEnd=void 0!==s.customEndingOffset?s.customEndingOffset*n:0,this._pattern=new ht,this._pattern.init(s.dashTemplate,!0),this._pattern.scale(n)}processPath(e){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[e]};if(!this.iteratePath){let r=!0;switch(this._endings){default:this._pattern.extPtGap=0;break;case"FullPattern":this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case"FullGap":this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case"NoConstraint":this.isClosed||(r=!1);break;case"Custom":this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const l=this._walker.calculatePathLength(e);if(this._pattern.isEmpty()||l<.1*this._pattern.length())return{paths:[e]};if(!this._walker.init(e,this._pattern,r))return{paths:[e]}}let s;if(this.iteratePath)s=this._pattern.nextValue();else{let r;switch(this._endings){default:r=.5*this._pattern.firstValue();break;case"HalfGap":r=.5*-this._pattern.lastValue();break;case"FullGap":r=-this._pattern.lastValue();break;case"FullPattern":r=0;break;case"NoConstraint":case"Custom":r=-this._customDashPos}let l=r/this._pattern.length();l-=Math.floor(l),r=l*this._pattern.length(),this._pattern.reset(),s=this._pattern.nextValue();let _=!1;for(;r>=s;)r-=s,s=this._pattern.nextValue(),_=!_;s-=r,_?(this._walker.nextPosition(s),s=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(s),s=this._pattern.nextValue(),this._walker.nextPosition(s),s=this._pattern.nextValue())}let n=this._walker.nextCurve(s);return n?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),X.mergePath(n,this._firstCurve),this._firstCurve=null)):(s=this._pattern.nextValue(),!this._walker.nextPosition(s)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(n=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,n=this._firstCurve,this._firstCurve=null),{paths:[n]}}}let Z=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new bt(s,n,r)}}return h.instance=null,h})();class bt{constructor(e,s,n){switch(this._inputGeometries=e,this._curveHelper=new O,this._width=(void 0!==s.width?s.width:2)*n,s.method){default:this._method="Mitered";break;case"Bevelled":this._method="Bevelled";break;case"Rounded":case"TrueBuffer":this._method="Rounded";break;case"Square":this._method="Square"}this._option=s.option,this._offsetFlattenError=J*n}next(){let e=this._inputGeometries.next();for(;e;){if((0,C.YX)(e)&&this._width>0){if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)-2*this._width<0)return e;const s=[];return s.push([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]),s.push([[e.xmin+this._width,e.ymin+this._width],[e.xmax-this._width,e.ymin+this._width],[e.xmax-this._width,e.ymax-this._width],[e.xmin+this._width,e.ymax-this._width],[e.xmin+this._width,e.ymin+this._width]]),{rings:s}}if((0,C.oU)(e)&&this._width>0){const s=[];for(const n of e.rings){const r=this._curveHelper.calculatePathLength(n),l=this._curveHelper.offset(n,this._width,this._method,4,this._offsetFlattenError);l&&(r<0&&l.reverse(),s.push(l))}if(s.length)return{rings:s}}e=this._inputGeometries.next()}return null}}let B=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new H(s,n,r)}}return h.instance=null,h})();class H extends I.zY{constructor(e,s,n){super(e,!1,!0),this._curveHelper=new O,this._length=(void 0!==s.length?s.length:20)*n,this._angle=void 0!==s.angle?s.angle:225,this._position=void 0!==s.position?s.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(e){if(this._curveHelper.isEmpty(e,!1))return null;const s=e[0],n=e[e.length-1];this._curveHelper.normalize([n[0]-s[0],n[1]-s[1]]);const l=[s[0]+(n[0]-s[0])*this._position/100,s[1]+(n[1]-s[1])*this._position/100],_=Math.cos((90-this._angle)/180*Math.PI);let p=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(p=-p),this._mirror=!this._mirror,{paths:[[s,[l[0]-this._length/2*_,l[1]-this._length/2*p],[l[0]+this._length/2*_,l[1]+this._length/2*p],n]]}}}let i=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new a(s,n,r)}}return h.instance=null,h})();class a{constructor(e,s,n){this._inputGeometries=e,this._offsetX=void 0!==s.offsetX?s.offsetX*n:0,this._offsetY=void 0!==s.offsetY?-s.offsetY*n:0}next(){let e=this._inputGeometries.next();for(;e;){if((0,C.YX)(e))return{xmin:e.xmin+this._offsetX,xmax:e.xmax+this._offsetX,ymin:e.ymin+this._offsetY,ymax:e.ymax+this._offsetY};if((0,C.oU)(e)){const s=(0,R.d9)(e);return this._moveMultipath(s.rings,this._offsetX,this._offsetY),s}if((0,C.l9)(e)){const s=(0,R.d9)(e);return this._moveMultipath(s.paths,this._offsetX,this._offsetY),s}if((0,C.aW)(e)){const s=(0,R.d9)(e);return this._movePath(s.points,this._offsetX,this._offsetY),s}if((0,C.wp)(e))return{x:e.x+this._offsetX,y:e.y+this._offsetY};e=this._inputGeometries.next()}return null}_moveMultipath(e,s,n){if(e)for(const r of e)this._movePath(r,s,n)}_movePath(e,s,n){if(e)for(const r of e)r[0]+=s,r[1]+=n}}let o=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new c(s,n,r)}}return h.instance=null,h})();class c{constructor(e,s,n){this._inputGeometries=e,this._curveHelper=new O,this._offset=(void 0!==s.offset?s.offset:1)*n,this._method=s.method,this._option=s.option,this._offsetFlattenError=J*n}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._offset)return e;if((0,C.YX)(e)){if("Rounded"===this._method&&this._offset>0){const n=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],this._offset,this._method,4,this._offsetFlattenError);return n?{rings:[n]}:null}if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._offset>0)return{xmin:e.xmin-this._offset,xmax:e.xmax+this._offset,ymin:e.ymin-this._offset,ymax:e.ymax+this._offset}}if((0,C.oU)(e)){const s=[];for(const n of e.rings){const r=this._curveHelper.offset(n,this._offset,this._method,4,this._offsetFlattenError);r&&s.push(r)}if(s.length)return{rings:s}}if((0,C.l9)(e)){const s=[];for(const n of e.paths){const r=this._curveHelper.offset(n,this._offset,this._method,4,this._offsetFlattenError);r&&s.push(r)}if(s.length)return{paths:s}}e=this._inputGeometries.next()}return null}}let u=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new f(s,n,r)}}return h.instance=null,h})();class f{constructor(e,s,n){this._inputGeometries=e,this._reverse=void 0===s.reverse||s.reverse}next(){let e=this._inputGeometries.next();for(;e;){if(!this._reverse)return e;if((0,C.l9)(e)){const s=(0,R.d9)(e);return(0,I.ov)(s.paths),s}e=this._inputGeometries.next()}return null}}var y=w(13638),g=w(25481);let L=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new b(s,n,r)}}return h.instance=null,h})();class b{constructor(e,s,n){this._inputGeometries=e,this._rotateAngle=void 0!==s.angle?-s.angle*Math.PI/180:0}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._rotateAngle)return e;const s=(0,y.Ue)();(0,g.$P)(s,e);const n=(s[2]+s[0])/2,r=(s[3]+s[1])/2;if((0,C.YX)(e)){const l={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._rotateMultipath(l.rings,n,r),l}if((0,C.oU)(e)){const l=(0,R.d9)(e);return this._rotateMultipath(l.rings,n,r),l}if((0,C.l9)(e)){const l=(0,R.d9)(e);return this._rotateMultipath(l.paths,n,r),l}if((0,C.aW)(e)){const l=(0,R.d9)(e);return this._rotatePath(l.points,n,r),l}if((0,C.wp)(e))return e;e=this._inputGeometries.next()}return null}_rotateMultipath(e,s,n){if(e)for(const r of e)this._rotatePath(r,s,n)}_rotatePath(e,s,n){if(e){const r=Math.cos(this._rotateAngle),l=Math.sin(this._rotateAngle);for(const _ of e){const p=_[0]-s,m=_[1]-n;_[0]=s+p*r-m*l,_[1]=n+p*l+m*r}}}}let k=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new W(s,n,r)}}return h.instance=null,h})();class W{constructor(e,s,n){this._inputGeometries=e,this._xFactor=void 0!==s.xScaleFactor?s.xScaleFactor:1.15,this._yFactor=void 0!==s.yScaleFactor?s.yScaleFactor:1.15}next(){let e=this._inputGeometries.next();for(;e;){if(1===this._xFactor&&1===this._yFactor)return e;const s=(0,y.Ue)();(0,g.$P)(s,e);const n=(s[2]+s[0])/2,r=(s[3]+s[1])/2;if((0,C.YX)(e)){const l={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._scaleMultipath(l.rings,n,r),l}if((0,C.oU)(e)){const l=(0,R.d9)(e);return this._scaleMultipath(l.rings,n,r),l}if((0,C.l9)(e)){const l=(0,R.d9)(e);return this._scaleMultipath(l.paths,n,r),l}if((0,C.aW)(e)){const l=(0,R.d9)(e);return this._scalePath(l.points,n,r),l}if((0,C.wp)(e))return e;e=this._inputGeometries.next()}return null}_scaleMultipath(e,s,n){if(e)for(const r of e)this._scalePath(r,s,n)}_scalePath(e,s,n){if(e)for(const r of e){const _=(r[1]-n)*this._yFactor;r[0]=s+(r[0]-s)*this._xFactor,r[1]=n+_}}}let Y=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new G(s,n,r)}}return h.instance=null,h})();class G{constructor(e,s,n){this._inputGeometries=e,this._height=(void 0!==s.amplitude?s.amplitude:2)*n,this._period=(void 0!==s.period?s.period:3)*n,this._style=s.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new ht,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new x,this._walker.updateTolerance(n)}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._height||0===this._period)return e;if((0,C.l9)(e)){const s=this._processGeom(e.paths);if(s.length)return{paths:s}}if((0,C.oU)(e)){const s=this._processGeom(e.rings);if(s.length)return{rings:s}}e=this._inputGeometries.next()}return null}_processGeom(e){const s=[];for(const n of e)if(this._walker.init(n,this._pattern))switch(this._style){default:s.push(this._constructCurve(n,!1));break;case"Square":s.push(this._constructSquare(n));break;case"Triangle":s.push(this._constructTriangle(n));break;case"Random":s.push(this._constructCurve(n,!0))}else s.push(n);return s}_constructCurve(e,s){const n=new X,r=this._walker.calculatePathLength(e);let l=Math.round(r/this._period);0===l&&(l=1);const m=this._period/16,M=1/(16*l+1),d=2*Math.PI*r/(r/l),A=2*Math.PI*Math.random(),S=2*Math.PI*Math.random(),v=2*Math.PI*Math.random(),E=.75-Math.random()/2,at=.75-Math.random()/2,F={};this._walker.curPointAndAngle(F),n.startPath(F.pt);let tt=0;for(;;){if(!this._walker.nextPointAndAngle(m,F)){n.lineTo(e[e.length-1]);break}{const j=tt;let U;if(tt+=M,s){const Pt=this._height/2*(1+.3*Math.sin(E*d*j+A));U=Pt*Math.sin(d*j+S),U+=Pt*Math.sin(at*d*j+v),U/=2}else U=.5*this._height*Math.sin(.5*d*j);n.lineTo([F.pt[0]-U*F.sa,F.pt[1]+U*F.ca])}}return n.path()}_constructSquare(e){const s=new X,n=this._walker.calculatePathLength(e);Math.round(n/this._period);let r=!0;for(;;){let l=!1;if(this._walker.curPositionIsValid()){const _={};this._walker.curPointAndAngle(_);const p={};if(this._walker.nextPointAndAngle(this._period,p)){const m={};this._walker.nextPointAndAngle(this._period,m)&&(r?(s.startPath(_.pt),r=!1):s.lineTo(_.pt),s.lineTo([_.pt[0]-this._height/2*_.sa,_.pt[1]+this._height/2*_.ca]),s.lineTo([p.pt[0]-this._height/2*p.sa,p.pt[1]+this._height/2*p.ca]),s.lineTo([p.pt[0]+this._height/2*p.sa,p.pt[1]-this._height/2*p.ca]),s.lineTo([m.pt[0]+this._height/2*m.sa,m.pt[1]-this._height/2*m.ca]),l=!0)}}if(!l){s.lineTo(this._walker.getPathEnd());break}}return s.path()}_constructTriangle(e){const s=new X,n=this._walker.calculatePathLength(e);Math.round(n/this._period);let r=!0;for(;;){let l=!1;if(this._walker.curPositionIsValid()){const _={};this._walker.curPointAndAngle(_);const p={};if(this._walker.nextPointAndAngle(this._period/2,p)){const m={};this._walker.nextPointAndAngle(this._period,m)&&(this._walker.nextPosition(this._period/2)&&(r?(s.startPath(_.pt),r=!1):s.lineTo(_.pt),s.lineTo([p.pt[0]-this._height/2*p.sa,p.pt[1]+this._height/2*p.ca]),s.lineTo([m.pt[0]+this._height/2*m.sa,m.pt[1]-this._height/2*m.ca])),l=!0)}}if(!l){s.lineTo(this._walker.getPathEnd());break}}return s.path()}}var T,h;(h=T||(T={})).NoConstraint="NoConstraint",h.WithMarkers="WithMarkers",h.WithFullGap="WithFullGap",h.WithHalfGap="WithHalfGap",h.Custom="Custom";let Q=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new ut(s,n,r)}}return h.instance=null,h})();class ut extends I.v1{constructor(e,s,n){super(e,!0,!0),this._grometryWalker=new x,this._grometryWalker.updateTolerance(n),this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*n:0,this._originalEndings=s.endings,this._offsetAtEnd=void 0!==s.customEndingOffset?s.customEndingOffset*n:0,this._position=void 0!==s.offsetAlongLine?s.offsetAlongLine*n:0,this._pattern=new ht,this._pattern.init(s.placementTemplate,!1),this._pattern.scale(n),this._endings=this._originalEndings}processPath(e){if(this._pattern.isEmpty())return null;let s;if(this.iteratePath)s=this._pattern.nextValue();else{this._endings=this._originalEndings===T.WithFullGap&&this.isClosed?T.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let r,l=!0;switch(this._endings){case T.NoConstraint:r=-this._position,r=this._adjustPosition(r),l=!1;break;default:r=-this._pattern.lastValue()/2;break;case T.WithFullGap:r=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case T.WithMarkers:r=0;break;case T.Custom:r=-this._position,r=this._adjustPosition(r),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._grometryWalker.init(e,this._pattern,l))return null;this._pattern.reset();let _=0;for(;r>_;)r-=_,_=this._pattern.nextValue();_-=r,s=_,this.iteratePath=!0}const n={};return this._grometryWalker.nextPointAndAngle(s,n)?this._endings===T.WithFullGap&&this._grometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===T.WithMarkers&&this._grometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(n.pt[0]+this._offset*n.sa,n.pt[1]-this._offset*n.ca),this._angleToLine&&this.internalPlacement.setRotateCS(n.ca,n.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(e){let s=e/this._pattern.length();return s-=Math.floor(s),s*this._pattern.length()}}let st=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new rt(s,n,r)}}return h.instance=null,h})();class rt extends I.v1{constructor(e,s,n){super(e,!1,!0),this._curveHelper=new O,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*n:0,this._type=s.extremityPlacement,this._position=void 0!==s.offsetAlongLine?s.offsetAlongLine*n:0,this._beginProcessed=!1}processPath(e){let s;switch(this._type){default:this._beginProcessed?(s=this._atExtremities(e,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(s=this._atExtremities(e,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case"JustBegin":s=this._atExtremities(e,this._position,!0);break;case"JustEnd":s=this._atExtremities(e,this._position,!1);case"None":}return s}_atExtremities(e,s,n){const r=e.length;if(r<2)return null;const _=n?r:-1,p=n?1:-1;let m,M=0,d=n?e[0]:e[r-1];for(let A=n?1:r-2;A!==_;A+=p){m=d,d=e[A];const S=this._curveHelper.calculateLength(m,d);if(M+S>s){const v=(s-M)/S,[E,at]=this._curveHelper.getAngleCS(m,d,v),F=(0,I.XV)(m,d,v);return this.internalPlacement.setTranslate(F[0]-this._offset*at,F[1]+this._offset*E),this._angleToLine&&this.internalPlacement.setRotateCS(-E,-at),this.internalPlacement}M+=S}return null}}let mt=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new it(s,n,r)}}return h.instance=null,h})();class it extends I.v1{constructor(e,s,n){super(e,!0,!0),this._walker=new x,this._walker.updateTolerance(n),this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*n:0,this._beginGap=void 0!==s.beginPosition?s.beginPosition*n:0,this._endGap=void 0!==s.endPosition?s.endPosition*n:0,this._flipFirst=void 0===s.flipFirst||s.flipFirst,this._pattern=new ht,this._pattern.init(s.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(e){if(this._pattern.isEmpty())return null;let s;if(this.iteratePath){const p=this._pattern.nextValue()*this._subPathLen,m=this._beginGap+p;s=m-this._prevPos,this._prevPos=m}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(e)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(e,this._pattern,!1))return null;this._pattern.reset();const p=this._pattern.nextValue()*this._subPathLen,m=this._beginGap+p;s=m-this._prevPos,this._prevPos=m,this.iteratePath=!0}const n={};if(!this._walker.nextPointAndAngle(s,n,1))return this.iteratePath=!1,null;let l,_;return this.internalPlacement.setTranslate(n.pt[0]+this._offset*n.sa,n.pt[1]-this._offset*n.ca),this._angleToLine?(l=n.ca,_=n.sa):(l=1,_=0),this._isFirst&&this._flipFirst&&(l=-l,_=-_),this.internalPlacement.setRotateCS(l,_),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var yt=w(68602);let ft=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new Mt(s,n,r)}}return h.instance=null,h})();class Mt{constructor(e,s,n){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._stepX=(void 0!==s.stepX?Math.abs(s.stepX):16)*n,this._stepY=(void 0!==s.stepY?Math.abs(s.stepY):16)*n,0!==this._stepX&&0!==this._stepY&&e&&function(h){return void 0!==h.rings}(e)&&e.rings){if(this._gridType=void 0!==s.gridType?s.gridType:"Fixed","Random"===this._gridType)this._randomness=void 0!==s.randomness?s.randomness/100:1,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0;else{if(this._randomness=0,this._gridAngle=void 0!==s.gridAngle?s.gridAngle:0,this._shiftOddRows=void 0!==s.shiftOddRows&&s.shiftOddRows,this._offsetX=void 0!==s.offsetX?s.offsetX*n:0,this._offsetY=void 0!==s.offsetY?s.offsetY*n:0,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}this._graphicOriginX=0,this._graphicOriginY=0,this._internalPlacement=new yt.u,this._calculateMinMax(e),this._geometry=e}}next(){return this._geometry?this._nextInside():null}_calculateMinMax(e){let s,n,r,l,_,p,m,M;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,_=p=Number.MAX_VALUE,m=M=-Number.MAX_VALUE;for(const d of e.rings){const A=d?d.length:0;for(let S=0;S<A;++S)s=d[S][0]-this._graphicOriginX-this._offsetX,n=d[S][1]-this._graphicOriginY-this._offsetY,r=this._cosAngle*s-this._sinAngle*n,l=this._sinAngle*s+this._cosAngle*n,_=Math.min(_,r),m=Math.max(m,r),p=Math.min(p,l),M=Math.max(M,l)}_+=this._graphicOriginX,m+=this._graphicOriginX,p+=this._graphicOriginY,M+=this._graphicOriginY,this._xMin=Math.round(_/this._stepX),this._xMax=Math.round(m/this._stepX),this._yMin=Math.round(p/this._stepY),this._yMax=Math.round(M/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let e=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(e+=.5*this._stepX);const s=this._currentY*this._stepY+this._offsetY;let n,r;return this._currentX++,"Random"===this._gridType?(n=this._graphicOriginX+e+this._stepX*this._randomness*(.5-Math.random())*2/3,r=this._graphicOriginY+s+this._stepY*this._randomness*(.5-Math.random())*2/3):(n=this._graphicOriginX+this._cosAngle*e+this._sinAngle*s,r=this._graphicOriginY-this._sinAngle*e+this._cosAngle*s),this._internalPlacement.setTranslate(n,r),this._internalPlacement}}}let vt=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new St(s,n,r)}}return h.instance=null,h})();class St extends I.v1{constructor(e,s,n){super(e,!0,!0),this._curveHelper=new O,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*n:0,this._relativeTo=s.relativeTo,this._position=void 0!==s.startPointOffset?s.startPointOffset*n:0,this._epsilon=.001*n}processPath(e){const s=this._position;if("SegmentMidpoint"===this._relativeTo){for(this.iteratePath||(this._segmentCount=e.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const r=this._curSegment;this._curSegment++;const l=e[r-1],_=e[r],p=this._curveHelper.calculateLength(l,_);if(p<this._epsilon)continue;const m=.5+this._position/p,[M,d]=this._curveHelper.getAngleCS(l,_,m),A=(0,I.XV)(l,_,m);return this.internalPlacement.setTranslate(A[0]-this._offset*d,A[1]+this._offset*M),this._angleToLine&&this.internalPlacement.setRotateCS(M,d),this.internalPlacement}return this.iteratePath=!1,null}"LineEnd"===this._relativeTo&&(0,I.hh)(e);const n=this.onLine(e,s);return"LineEnd"===this._relativeTo&&(0,I.hh)(e),n}onLine(e,s){let n,r=!1;switch(this._relativeTo){default:n=this._curveHelper.calculatePathLength(e)/2+s;break;case"LineBeginning":n=s;break;case"LineEnd":n=s,r=!0}const l=e.length;let _,p=0,m=e[0];for(let M=1;M<l;++M){_=m,m=e[M];const d=this._curveHelper.calculateLength(_,m);if(p+d>n){const A=(n-p)/d,[S,v]=this._curveHelper.getAngleCS(_,m,A),E=(0,I.XV)(_,m,A),at=r?this._offset:-this._offset;return this.internalPlacement.setTranslate(E[0]-at*v,E[1]+at*S),this._angleToLine&&(r?this.internalPlacement.setRotateCS(-S,-v):this.internalPlacement.setRotateCS(S,v)),this.internalPlacement}p+=d}return null}}let At=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new Gt(s,n,r)}}return h.instance=null,h})();class Gt extends I.v1{constructor(e,s,n){super(e,!0,!0),this._curveHelper=new O,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*n:0,this._endPoints=void 0===s.placeOnEndPoints||s.placeOnEndPoints,this._controlPoints=void 0===s.placeOnControlPoints||s.placeOnControlPoints,this._regularVertices=void 0===s.placeOnRegularVertices||s.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(e){if(this.iteratePath||(this._preparePath(e),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const s=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(s[2]);let n=s[0],r=s[1];if(0!==this._offset){const l=Math.cos(s[2]),_=Math.sin(s[2]);n-=this._offset*_,r+=this._offset*l}return this.internalPlacement.setTranslate(n,r),this._tagIterator++,this.internalPlacement}_preparePath(e){this._tags.length=0,this._tagIterator=0;const s=(0,I.QK)(e),n=e.length-1;let r,l,_=0,p=0,m=0,M=0,d=0;for(;_<n;){_++,r=e[_-1],l=e[_];const A=(0,I.zv)(r),S=(0,I.zv)(l);(this._angleToLine||0!==this._offset)&&(M=this._curveHelper.getAngle(r,l,0)),1===_?s?(p=M,m=A):this._endPoints&&this._tags.push([r[0],r[1],M]):1===A?this._controlPoints&&this._tags.push([r[0],r[1],wt(d,M)]):this._regularVertices&&this._tags.push([r[0],r[1],wt(d,M)]),(this._angleToLine||0!==this._offset)&&(d=this._curveHelper.getAngle(r,l,1)),_===n&&(s?1===S||1===m?this._controlPoints&&this._tags.push([l[0],l[1],wt(d,p)]):this._regularVertices&&this._tags.push([l[0],l[1],wt(d,p)]):this._endPoints&&this._tags.push([l[0],l[1],d]))}this._tagIterator=0}}function wt(h,e){const s=Math.PI;for(;Math.abs(e-h)>s+2e-15;)e-h>s?e-=2*s:e+=2*s;return(h+e)/2}let Ft=(()=>{class h{static local(){return null===h.instance&&(h.instance=new h),h.instance}execute(s,n,r){return new Xt(s,n,r)}}return h.instance=null,h})();class Xt{constructor(e,s,n){this._geometry=e,this._offsetX=void 0!==s.offsetX?s.offsetX*n:0,this._offsetY=void 0!==s.offsetY?s.offsetY*n:0,this._method=void 0!==s.method?s.method:"OnPolygon",this._internalPlacement=new yt.u}next(){const e=this._geometry;return this._geometry=null,e&&function(h){return void 0!==h.rings}(e)?this._polygonCenter(e):null}_polygonCenter(e){let s=!1;switch(this._method){default:{const n=(0,y.Ue)();(0,g.$P)(n,e),this._internalPlacement.setTranslate((n[2]+n[0])/2+this._offsetX,(n[3]+n[1])/2-this._offsetY),s=!0;break}}return s?this._internalPlacement:null}}function Ot(h){if(!h)return null;switch(h.type){case"CIMGeometricEffectAddControlPoints":return z.local();case"CIMGeometricEffectArrow":return ot.local();case"CIMGeometricEffectBuffer":return _t.local();case"CIMGeometricEffectCut":return dt.local();case"CIMGeometricEffectDashes":return D.local();case"CIMGeometricEffectDonut":return Z.local();case"CIMGeometricEffectJog":return B.local();case"CIMGeometricEffectMove":return i.local();case"CIMGeometricEffectOffset":return o.local();case"CIMGeometricEffectReverse":return u.local();case"CIMGeometricEffectRotate":return L.local();case"CIMGeometricEffectScale":return k.local();case"CIMGeometricEffectWave":return Y.local()}return null}function Yt(h){if(!h)return null;switch(h.type){case"CIMMarkerPlacementAlongLineSameSize":return Q.local();case"CIMMarkerPlacementAtExtremities":return st.local();case"CIMMarkerPlacementAtRatioPositions":return mt.local();case"CIMMarkerPlacementInsidePolygon":return ft.local();case"CIMMarkerPlacementOnLine":return vt.local();case"CIMMarkerPlacementOnVertices":return At.local();case"CIMMarkerPlacementPolygonCenter":return Ft.local()}return null}},68602:(et,V,w)=>{w.d(V,{u:()=>R});class R{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rz_c&&0!==this.rz_s)&&(this.rz=Math.atan2(this.rz_s,this.rz_c)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rz_c=1,this.rz_s=0}setTranslate(z,N){this.tx=z,this.ty=N}setTranslateZ(z){this.tz=z}setRotateCS(z,N){this.rz=void 0,this.rz_c=z,this.rz_s=N}setRotate(z){this.rz=z,this.rz_c=void 0,this.rz_s=void 0}setRotateY(z){this.ry=z}setScale(z){this.s=z}setMeasure(z){this.m=z}}},79391:(et,V,w)=>{w.d(V,{B$:()=>Z,E0:()=>B,fN:()=>bt});var R=w(68322),C=w(33870),I=w(22791),z=w(68602),N=w(13638),J=w(25481),X=w(52917),O=w(14511),$=w(60196),nt=w(35779);const K=Math.PI/180,ot=C.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class q{constructor(i){this._t=i}static createIdentity(){return new q([1,0,0,0,1,0])}clone(){return new q(this._t.slice())}transform(i){const a=this._t;return[a[0]*i[0]+a[1]*i[1]+a[2],a[3]*i[0]+a[4]*i[1]+a[5]]}static createScale(i,a){return new q([i,0,0,0,a,0])}scale(i,a){const o=this._t;return o[0]*=i,o[1]*=i,o[2]*=i,o[3]*=a,o[4]*=a,o[5]*=a,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(i,a){return new q([0,0,i,0,0,a])}translate(i,a){const o=this._t;return o[2]+=i,o[5]+=a,this}static createRotate(i){const a=Math.cos(i),o=Math.sin(i);return new q([a,-o,0,o,a,0])}rotate(i){return this.multiply(q.createRotate(i))}multiply(i){const a=this._t,o=i._t,u=a[1]*o[0]+a[4]*o[1],f=a[2]*o[0]+a[5]*o[1]+o[2],y=a[0]*o[3]+a[3]*o[4],g=a[1]*o[3]+a[4]*o[4],L=a[2]*o[3]+a[5]*o[4]+o[5];return a[0]=a[0]*o[0]+a[3]*o[1],a[1]=u,a[2]=f,a[3]=y,a[4]=g,a[5]=L,this}}class _t{constructor(i){this._transfos=[],this._sizeTransfos=[],this._transfos.push(i||q.createIdentity()),this._sizeTransfos.push(i?i.scaleRatio():1)}transformPt(i){return this._transfos[this._transfos.length-1].transform(i)}transformSize(i){return i*this._sizeTransfos[this._sizeTransfos.length-1]}back(){return this._transfos[this._transfos.length-1]}push(i,a){const o=a?i.scaleRatio():1;i.multiply(this.back()),this._transfos.push(i),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*o)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(i,a){if(i)switch(i.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(i,a)}}drawMultiLayerSymbol(i,a){if(!i)return;const o=i.symbolLayers;if(!o)return;const c=i.effects;if(c){const u=this.executeEffects(c,a);if(u){let f=u.next();for(;f;)this.drawSymbolLayers(o,f),f=u.next()}}else this.drawSymbolLayers(o,a)}executeEffects(i,a){let c=new O.M(a);for(const u of i){const f=(0,$.h)(u);f&&(c=f.execute(c,u,1))}return c}drawSymbolLayers(i,a){let o=i.length;for(;o--;){const c=i[o];if(!c||!1===c.enable)continue;const u=c.effects;if(u){const f=this.executeEffects(u,a);if(f){let y=f.next();for(;y;)this.drawSymbolLayer(c,y),y=f.next()}}else this.drawSymbolLayer(c,a)}}drawSymbolLayer(i,a){switch(i.type){case"CIMSolidFill":this.drawSolidFill(a,i.color);break;case"CIMHatchFill":this.drawHatchFill(i,a);break;case"CIMSolidStroke":this.drawSolidStroke(a,i.color,i.width,i.capStyle,i.joinStyle,i.miterLimit);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(i,a)}}drawHatchFill(i,a){const c=this._buildHatchPolyline(i,a,1);c&&(this.pushClipPath(a),this.drawMultiLayerSymbol(i.lineSymbol,c),this.popClipPath())}drawMarkerLayer(i,a){const o=i.markerPlacement;if(o){const c=(0,$.W)(o);if(c){const u="CIMMarkerPlacementInsidePolygon"===o.type;u&&this.pushClipPath(a);const y=c.execute(a,o,1);if(y){let g=y.next();for(;g;)this.drawMarker(i,g),g=y.next()}u&&this.popClipPath()}}else{const c=new z.u;c.tx=a.x,c.ty=a.y,this.drawMarker(i,c)}}drawMarker(i,a){switch(i.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(i,a);break;case"CIMVectorMarker":this.drawVectorMarker(i,a)}}drawPictureMarker(i,a){if(!i)return;const o=i.size||10,c=q.createIdentity(),u=i.anchorPoint;if(u){let f=u.x,y=u.y;"Absolute"!==i.anchorPointUnits&&(f*=o,y*=o),c.translate(-f,-y)}i.rotation&&c.rotate(i.rotation*K),c.translate(i.offsetX||0,i.offsetY||0),c.translate(a.tx,a.ty),this.push(c,!1),this.drawImage(i.url,o,i.scaleX),this.pop()}drawVectorMarker(i,a){if(!i)return;const o=i.markerGraphics;if(!o)return;const c=i.size,u=i.frame,f=u?u.ymax-u.ymin:0,y=c&&f?c/f:1,g=q.createIdentity();u&&g.translate(.5*-(u.xmax+u.xmin),.5*-(u.ymax+u.ymin));const L=i.anchorPoint;if(L){let b=L.x,k=L.y;"Absolute"!==i.anchorPointUnits?u&&(b*=u.xmax-u.xmin,k*=u.ymax-u.ymin):(b/=y,k/=y),g.translate(-b,-k)}1!==y&&g.scale(y,y),i.rotation&&g.rotate(i.rotation*K),g.translate(i.offsetX||0,i.offsetY||0),g.translate(a.tx,a.ty),this.push(g,i.scaleSymbolsProportionally);for(const b of o)b&&b.symbol&&b.geometry||ot.error("Invalid marker graphic",b),this.drawSymbol(b.symbol,b.geometry);this.pop()}_buildHatchPolyline(i,a,o){let c=(void 0!==i.separation?i.separation:4)*o,u=void 0!==i.rotation?i.rotation:0;if(0===c)return null;c<0&&(c=-c);let f=0;const y=.5*c;for(;f>y;)f-=c;for(;f<-y;)f+=c;const g=(0,N.Ue)();(0,J.$P)(g,a),g[0]-=y,g[1]-=y,g[2]+=y,g[3]+=y;const L=[[g[0],g[1]],[g[0],g[3]],[g[2],g[3]],[g[2],g[1]]];for(;u>180;)u-=180;for(;u<0;)u+=180;const b=Math.cos(u*K),k=Math.sin(u*K),W=-c*k,Y=c*b;let G,T,Q,ut;f=(void 0!==i.offsetX?i.offsetX*o:0)*k-(void 0!==i.offsetY?i.offsetY*o:0)*b,G=Q=Number.MAX_VALUE,T=ut=-Number.MAX_VALUE;for(const ft of L){const Mt=ft[0],Ct=ft[1],vt=b*Mt+k*Ct,St=-k*Mt+b*Ct;G=Math.min(G,vt),Q=Math.min(Q,St),T=Math.max(T,vt),ut=Math.max(ut,St)}Q=Math.floor(Q/c)*c;let st=b*G-k*Q-W*f/c,rt=k*G+b*Q-Y*f/c,mt=b*T-k*Q-W*f/c,it=k*T+b*Q-Y*f/c;const yt=1+Math.round((ut-Q)/c),xt=[];for(let ft=0;ft<yt;ft++)st+=W,rt+=Y,mt+=W,it+=Y,xt.push([[st,rt],[mt,it]]);return{paths:xt}}}class gt extends _t{constructor(){super(),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new nt.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}drawSolidFill(i){if(i&&!(this._clipCount>0))if((0,X.oU)(i))this._processPath(i.rings,0);else if((0,X.l9)(i))this._processPath(i.paths,0);else if((0,X.YX)(i)){const a=ct(i);a&&this._processPath(a.rings,0)}}drawSolidStroke(i,a,o){if(!i||this._clipCount>0)return;const c=.5*this.transformSize(o);if((0,X.oU)(i))this._processPath(i.rings,c);else if((0,X.l9)(i))this._processPath(i.paths,c);else if((0,X.YX)(i)){const u=ct(i);u&&this._processPath(u.rings,c)}}pushClipPath(i){this.drawSolidFill(i),++this._clipCount}popClipPath(){--this._clipCount}drawImage(i,a,o){const c=a/2;this._merge(this.transformPt([0,0]),c)}_processPath(i,a){if(i)for(const o of i){const c=o?o.length:0;if(c>1){this._merge(this.transformPt(o[0]),a);for(let u=1;u<c;++u)this._merge(this.transformPt(o[u]),a)}}}_merge(i,a){i[0]-a<this._xmin&&(this._xmin=i[0]-a),i[0]+a>this._xmax&&(this._xmax=i[0]+a),i[1]-a<this._ymin&&(this._ymin=i[1]-a),i[1]+a>this._ymax&&(this._ymax=i[1]+a)}}class dt extends _t{constructor(i,a){super(a),this._ctx=i}drawSolidFill(i,a){if(!i)return;if((0,X.oU)(i))this._buildPath(i.rings,!0);else if((0,X.l9)(i))this._buildPath(i.paths,!0);else{if(!(0,X.YX)(i))return;this._buildPath(ct(i).rings,!0)}const o=this._ctx;o.fillStyle="string"==typeof a?a:"rgba("+Math.round(a[0])+","+Math.round(a[1])+","+Math.round(a[2])+","+a[3]/255+")",o.fill("evenodd")}drawSolidStroke(i,a,o,c,u,f){if(!i||!a||0===o)return;if((0,X.oU)(i))this._buildPath(i.rings,!0);else if((0,X.l9)(i))this._buildPath(i.paths,!1);else{if(!(0,X.YX)(i))return;this._buildPath(ct(i).rings,!0)}const y=this._ctx;y.strokeStyle="string"==typeof a?a:"rgba("+Math.round(a[0])+","+Math.round(a[1])+","+Math.round(a[2])+","+a[3]/255+")",y.lineWidth=this.transformSize(o)+.5,this._setCapStyle(c),this._setJoinStyle(u),y.miterLimit=f,y.stroke()}pushClipPath(i){if(this._ctx.save(),(0,X.oU)(i))this._buildPath(i.rings,!0);else if((0,X.l9)(i))this._buildPath(i.paths,!0);else{if(!(0,X.YX)(i))return;this._buildPath(ct(i).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(i,a,o){}_buildPath(i,a){const o=this._ctx;if(o.beginPath(),i)for(const c of i){const u=c?c.length:0;if(u>1){let f=this.transformPt(c[0]);o.moveTo(f[0],f[1]);for(let y=1;y<u;++y)f=this.transformPt(c[y]),o.lineTo(f[0],f[1]);a&&o.closePath()}}}_setCapStyle(i){switch(i){case"Butt":this._ctx.lineCap="butt";break;case"Round":this._ctx.lineCap="round";break;case"Square":this._ctx.lineCap="square"}}_setJoinStyle(i){switch(i){case"Bevel":this._ctx.lineJoin="bevel";break;case"Round":this._ctx.lineJoin="round";break;case"Miter":this._ctx.lineJoin="miter"}}}const ct=H=>H?{spatialReference:H.spatialReference,rings:[[[H.xmin,H.ymin],[H.xmin,H.ymax],[H.xmax,H.ymax],[H.xmax,H.ymin],[H.xmin,H.ymin]]]}:null;var pt=w(94368);const ht=Math.PI,P=ht/2,D=C.Z.getLogger("esri.symbols.cim.CIMSymbolHelper");function lt(H,i){switch(i.type){case"CIMSymbolReference":H.drawSymbol(i.symbol,{type:"point",x:0,y:0});break;case"CIMPointSymbol":H.drawSymbol(i,{type:"point",x:0,y:0});break;case"CIMTextSymbol":break;case"CIMVectorMarker":{const a=new z.u;H.drawMarker(i,a);break}}return H.envelope()}class Z{static getEnvelope(i){const a=new gt;if(Array.isArray(i)){let o;for(const c of i)o?o.union(lt(a,c)):o=lt(a,c);return o}return lt(a,i)}static getTextureAnchor(i){const a=this.getEnvelope(i);if(!a||a.width<=0||a.height<=0)return[0,0,0];const o=96/72,y=a.height*o+2;return[(a.x+.5*a.width)*o/(a.width*o+2),-(a.y+.5*a.height)*o/y,y]}static rasterize(i,a,o,c=!0){const u=o||this.getEnvelope(a);if(!u||u.width<=0||u.height<=0)return[null,0,0,0,0];const f=96/72,y=(u.x+.5*u.width)*f,g=(u.y+.5*u.height)*f;i.width=u.width*f,i.height=u.height*f,o||(i.width+=2,i.height+=2);const L=i.getContext("2d"),b=q.createScale(f,-f);b.translate(.5*i.width-y,.5*i.height+g);const k=new dt(L,b);switch(a.type){case"CIMPointSymbol":k.drawSymbol(a,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const G=new z.u;k.drawMarker(a,G);break}}const W=L.getImageData(0,0,i.width,i.height),Y=new Uint8Array(W.data);if(c){let G;for(let T=0;T<Y.length;T+=4)G=Y[T+3]/255,Y[T]=Y[T]*G,Y[T+1]=Y[T+1]*G,Y[T+2]=Y[T+2]*G}return[Y,i.width,i.height,-y/i.width,-g/i.height]}static fromSimpleMarker(i){const o=50;let c,u;const f=i.style;if("circle"===f||"esriSMSCircle"===f){let L=Math.acos(.995),b=Math.ceil(ht/L/4);0===b&&(b=1),L=P/b,b*=4;const k=[];k.push([o,0]);for(let W=1;W<b;W++)k.push([o*Math.cos(W*L),-o*Math.sin(W*L)]);k.push([o,0]),c={rings:[k]},u={xmin:-o,ymin:-o,xmax:o,ymax:o}}else if("cross"===f||"esriSMSCross"===f){const g=0;c={rings:[[[g,o],[g,g],[o,g],[o,-g],[g,-g],[g,-o],[-g,-o],[-g,-g],[-o,-g],[-o,g],[-g,g],[-g,o],[g,o]]]},u={xmin:-o,ymin:-o,xmax:o,ymax:o}}else if("diamond"===f||"esriSMSDiamond"===f)c={rings:[[[-o,0],[0,o],[o,0],[0,-o],[-o,0]]]},u={xmin:-o,ymin:-o,xmax:o,ymax:o};else if("square"===f||"esriSMSSquare"===f)c={rings:[[[-o,-o],[-o,o],[o,o],[o,-o],[-o,-o]]]},u={xmin:-o,ymin:-o,xmax:o,ymax:o};else if("x"===f||"esriSMSX"===f){const g=0;c={rings:[[[0,g],[o-g,o],[o,o-g],[g,0],[o,g-o],[o-g,-o],[0,-g],[g-o,-o],[-o,g-o],[-g,0],[-o,o-g],[g-o,o],[0,g]]]},u={xmin:-o,ymin:-o,xmax:o,ymax:o}}else if("triangle"===f||"esriSMSTriangle"===f){const g=57.735026918962575,L=-g,b=2/3*100,k=b-100;c={rings:[[[L,k],[0,b],[g,k],[L,k]]]},u={xmin:L,ymin:k,xmax:g,ymax:b}}else"arrow"!==f&&"esriSMSArrow"!==f||(c={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},u={xmin:-o,ymin:-o,xmax:o,ymax:o});let y;if(c&&u){const g=[{type:"CIMSolidFill",enable:!0,color:i.color}];i.outline&&g.push({type:"CIMSolidStroke",enable:!0,width:i.outline.width,color:i.outline.color}),y={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:i.angle,size:i.size,offsetX:i.xoffset,offsetY:i.yoffset,frame:u,markerGraphics:[{type:"CIMMarkerGraphic",geometry:c,symbol:{type:"CIMPolygonSymbol",symbolLayers:g}}]}]}}return y}static fromCIMHatchFill(i){const a=void 0!==i.separation?i.separation:4,o=a/2;let c=this._getLineSymbolPeriod(i.lineSymbol)||4;for(;c<4;)c*=2;const u=c/2;return{type:"CIMVectorMarker",frame:{xmin:-u,xmax:u,ymin:-o,ymax:o},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-u,0],[u,0]]]},symbol:i.lineSymbol}],size:a}}static _getLineSymbolPeriod(i){if(i){const a=this._getEffectsRepeat(i.effects);if(a)return a;if(i.symbolLayers)for(const o of i.symbolLayers){const c=this._getEffectsRepeat(o.effects);if(c)return c;if(o){const u=this._getPlacementRepeat(o.markerPlacement);if(u)return u}}}return 0}static _getEffectsRepeat(i){if(i)for(const a of i)if(a)switch(a.type){case"CIMGeometricEffectDashes":{const o=a.dashTemplate;if(o&&o.length){let c=0;for(const u of o)c+=u;return 1&o.length&&(c*=2),c}break}case"CIMGeometricEffectWave":return a.period;default:D.error(`unsupported geometric effect type ${a.type}`)}return 0}static _getPlacementRepeat(i){if(i)switch(i.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const a=i.placementTemplate;if(a&&a.length){let o=0;for(const c of a)o+=c;return 1&a.length&&(o*=2),o}break}}return 0}static fromCIMInsidePolygon(i){const a=i.markerPlacement,o=Et({type:i.type},i);let c,u,f,y;return o.markerPlacement=null,o.anchorPoint=null,!0===a.shiftOddRows?(u=a.stepX/2,f=a.stepY,y=2*a.stepY,c=[{x:-u,y:0},{x:u,y:0},{x:0,y:f},{x:0,y:-f}].map(g=>({type:"CIMMarkerGraphic",geometry:g,symbol:{type:"CIMPointSymbol",symbolLayers:[o]}}))):(u=a.stepX/2,f=a.stepY/2,y=a.stepY,c=[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMPointSymbol",symbolLayers:[o]}}]),{type:"CIMVectorMarker",frame:{xmin:-u,xmax:u,ymin:-f,ymax:f},markerGraphics:c,size:y}}static getFillColor(i){if(!i)return null;switch(i.type){case"CIMPolygonSymbol":if(i.symbolLayers)for(const a of i.symbolLayers){const o=Z.getFillColor(a);if(null!=o)return o}break;case"CIMTextSymbol":return Z.getFillColor(i.symbol);case"CIMSolidFill":return i.color}}static getStrokeColor(i){if(i)switch(i.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(i.symbolLayers)for(const a of i.symbolLayers){const o=Z.getStrokeColor(a);if(void 0!==o)return o}break;case"CIMTextSymbol":return Z.getStrokeColor(i.symbol);case"CIMSolidStroke":return i.color}}static getStrokeWidth(i){if(i)switch(i.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(i.symbolLayers)for(const a of i.symbolLayers){const o=Z.getStrokeWidth(a);if(void 0!==o)return o}break;case"CIMTextSymbol":return Z.getStrokeWidth(i.symbol);case"CIMSolidStroke":case"CIMGradientStroke":case"CIMPictureStroke":return i.width}}static getSize(i){if(i)switch(i.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{let a=0;if(i.symbolLayers)for(const o of i.symbolLayers){const c=Z.getSize(o);c>a&&(a=c)}return a}case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":return i.width;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":return i.size}}static getMarkerScaleRatio(i){return i&&"CIMVectorMarker"===i.type&&!1!==i.scaleSymbolsProportionally&&i.frame?i.size/(i.frame.ymax-i.frame.ymin):1}}class bt{static rasterizeSimpleFill(i,a,o){"solid"!==a&&"none"!==a&&"esriSFSSolid"!==a&&"esriSFSNull"!==a||console.error("Unexpected: style does not require rasterization");const c=(0,I.fp)(Math.ceil(o)),u=this._isHorizontalOrVertical(a)?8*c:16*c,f=2*c;i.width=u,i.height=u;const y=i.getContext("2d");y.strokeStyle="#FFFFFF",y.lineWidth=c,y.beginPath(),"vertical"!==a&&"cross"!==a&&"esriSFSCross"!==a&&"esriSFSVertical"!==a||(y.moveTo(u/2,-f),y.lineTo(u/2,u+f)),"horizontal"!==a&&"cross"!==a&&"esriSFSCross"!==a&&"esriSFSHorizontal"!==a||(y.moveTo(-f,u/2),y.lineTo(u+f,u/2)),"forward-diagonal"!==a&&"diagonal-cross"!==a&&"esriSFSDiagonalCross"!==a&&"esriSFSForwardDiagonal"!==a||(y.moveTo(-f,-f),y.lineTo(u+f,u+f),y.moveTo(u-f,-f),y.lineTo(u+f,f),y.moveTo(-f,u-f),y.lineTo(f,u+f)),"backward-diagonal"!==a&&"diagonal-cross"!==a&&"esriSFSBackwardDiagonal"!==a&&"esriSFSDiagonalCross"!==a||(y.moveTo(u+f,-f),y.lineTo(-f,u+f),y.moveTo(f,-f),y.lineTo(-f,f),y.moveTo(u+f,u-f),y.lineTo(u-f,u+f)),y.stroke();const g=y.getImageData(0,0,i.width,i.height),L=new Uint8Array(g.data);let b;for(let k=0;k<L.length;k+=4)b=L[k+3]/255,L[k]=L[k]*b,L[k+1]=L[k+1]*b,L[k+2]=L[k+2]*b;return[L,i.width,i.height]}static rasterizeSimpleLine(i,a){let o;switch(a){case"butt":o="Butt";break;case"square":o="Square";break;default:o="Round"}const c="Butt"===o;let u;switch(i){case"dash":case"esriSLSDash":u=c?[4,3]:[3,4];break;case"dash-dot":case"esriSLSDashDot":u=c?[4,3,1,3]:[3,4,0,4];break;case"dot":case"esriSLSDot":u=c?[1,3]:[0,4];break;case"long-dash":case"esriSLSLongDash":u=c?[8,3]:[7,4];break;case"long-dash-dot":case"esriSLSLongDashDot":u=c?[8,3,1,3]:[7,4,0,4];break;case"long-dash-dot-dot":case"esriSLSDashDotDot":u=c?[8,3,1,3,1,3]:[7,4,0,4,0,4];break;case"short-dash":case"esriSLSShortDash":u=c?[4,1]:[3,2];break;case"short-dash-dot":case"esriSLSShortDashDot":u=c?[4,1,1,1]:[3,2,0,2];break;case"short-dash-dot-dot":case"esriSLSShortDashDotDot":u=c?[4,1,1,1,1,1]:[3,2,0,2,0,2];break;case"short-dot":case"esriSLSShortDot":u=c?[1,1]:[0,2];break;case"solid":case"esriSLSSolid":case"none":D.error("Unexpected: style does not require rasterization"),u=[0,0];break;default:D.error(`Tried to rasterize SLS, but found an unexpected style: ${i}!`),u=[0,0]}return this.rasterizeDash(u,o)}static rasterizeDash(i,a){const o="Butt"===a,c="Square"===a,u=!o&&!c;i.length%2==1&&(i=[...i,...i]);const f=15.5;let g=0;for(const st of i)g+=st;const L=Math.round(g*f),b=new Float32Array(31*L),k=7.75;let W=0,Y=0,G=.5,T=!0;for(const st of i){for(W=Y,Y+=st*f;G<=Y;){let rt=.5;for(;rt<31;){const mt=(rt-.5)*L+G-.5,it=u?(rt-f)*(rt-f):Math.abs(rt-f);b[mt]=T?o?Math.max(Math.max(W+k-G,it),Math.max(G-Y+k,it)):it:u?Math.min((G-W)*(G-W)+it,(G-Y)*(G-Y)+it):c?Math.min(Math.max(G-W,it),Math.max(Y-G,it)):Math.min(Math.max(G-W+k,it),Math.max(Y+k-G,it)),rt++}G++}T=!T}const Q=b.length,ut=new Uint8Array(4*Q);for(let st=0;st<Q;++st){const rt=(u?Math.sqrt(b[st]):b[st])/f;(0,pt.I)(rt,ut,4*st)}return[ut,L,31]}static _isHorizontalOrVertical(i){return"vertical"===i||"horizontal"===i||"cross"===i||"esriSFSCross"===i||"esriSFSVertical"===i||"esriSFSHorizontal"===i}}class B{static findApplicableOverrides(i,a,o){if(a){if(i.primitiveName){let c=!1;for(const u of o)if(u.primitiveName===i.primitiveName){c=!0;break}if(!c)for(const u of a)u.primitiveName===i.primitiveName&&o.push(u)}switch(i.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(i.effects)for(const c of i.effects)B.findApplicableOverrides(c,a,o);if(i.symbolLayers)for(const c of i.symbolLayers)B.findApplicableOverrides(c,a,o);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(i.effects)for(const c of i.effects)B.findApplicableOverrides(c,a,o);if(i.markerPlacement&&B.findApplicableOverrides(i.markerPlacement,a,o),"CIMVectorMarker"===i.type){if(i.markerGraphics)for(const c of i.markerGraphics)B.findApplicableOverrides(c,a,o),B.findApplicableOverrides(c.symbol,a,o)}else"CIMCharacterMarker"===i.type?B.findApplicableOverrides(i.symbol,a,o):"CIMHatchFill"===i.type&&B.findApplicableOverrides(i.lineSymbol,a,o)}}}static applyOverrides(i,a,o,c){if(!a)return;const u=f=>f&&f.charAt(0).toLowerCase()+f.substr(1);if(i.primitiveName)for(const f of a)if(f.primitiveName===i.primitiveName){const y=u(f.propertyName);if(c&&c.push({cim:i,nocapPropertyName:y,value:i[y]}),f.expression&&(f.value=B.toValue(f.propertyName,f.expression)),o){let g=!1;for(const L of o)L.primitiveName===i.primitiveName&&(g=!0);g||o.push(f)}i[y]=f.value}switch(i.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(i.effects)for(const f of i.effects)B.applyOverrides(f,a,o,c);if(i.symbolLayers)for(const f of i.symbolLayers)B.applyOverrides(f,a,o,c);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(i.effects)for(const f of i.effects)B.applyOverrides(f,a,o,c);if("CIMVectorMarker"===i.type&&i.markerGraphics)for(const f of i.markerGraphics)B.applyOverrides(f,a,o,c),B.applyOverrides(f.symbol,a,o,c)}}static restoreOverrides(i){for(const a of i)a.cim[a.nocapPropertyName]=a.value}static buildOverrideKey(i){let a="";for(const o of i)void 0!==o.value&&(a+=`${o.primitiveName}${o.propertyName}${JSON.stringify(o.value)}`);return a}static toValue(i,a){if("DashTemplate"===i)return a.split(" ").map(o=>Number(o));if("Color"===i){const o=new R.Z(a).toRgba();return o[3]*=255,o}return a}}},35779:(et,V,w)=>{w.d(V,{Z:()=>R});class R{constructor(I=0,z=0,N=0,J=0){this.x=I,this.y=z,this.width=N,this.height=J}get isEmpty(){return this.width<=0||this.height<=0}union(I){this.x=Math.min(this.x,I.x),this.y=Math.min(this.y,I.y),this.width=Math.max(this.width,I.width),this.height=Math.max(this.height,I.height)}}},94368:(et,V,w)=>{w.d(V,{I:()=>z});const R=[1,256,65536,16777216],C=[1/256,1/65536,1/16777216,1/4294967296],I=function(O,$=0){let nt=0;for(let K=0;K<4;K++)nt+=O[$+K]*C[K];return nt}(new Uint8ClampedArray([255,255,255,255]));function z(O,$,nt=0){const K=function(O,$,nt){return O<0?0:O>nt?nt:O}(O,0,I);for(let ot=0;ot<4;ot++)$[nt+ot]=Math.floor(256*X(K*R[ot]))}function X(O){return O-Math.floor(O)}}}]);